# 누군가 요약한 클린코드

1장(깨끗한 코드):

- 르블랑의 법치(LeBlanc's law): "나중은 결코 오지 않는다"
- 깨끗한 코드: 자명하면서 중복이 없는 코드
- 좋은 이름: 명확한 의도, 쉬운 발음, 일관성, 클래스=명사/명사구, 메소드=동사/동사구, IDE를 방해하지 마라
- 좋은 함수: 작음(20줄 이하, 2단 들여쓰기 이내, 2 인자 이내), 한 가지만 수행(no side effect), 서술적 이름, 명령-조회 분리, 예외 사용
- 좋은 주석: 최소! 정확! 법, 정보, 의도, 의미, 경고 제공
- 좋은 형식: 빈 행으로 의미 구분하기, 서로 밀접(호출 관계, 유사성)한 개념은 가까이, 가로 길이는 최소화
- 좋은 객체 or 자료 구조: 자료 구조(새로운 동작 추가에 유리)와 객체(새로운 타입 추가에 유리)의 구분, 디미터 법칙(속사정은 알 필요 없다)
- 좋은 오류 처리: 오류 코드 쓰지 말고 예외를 사용, unchecked 예외 사용, 예외에 의미 제공, null은 전달도 반환도 하지 마라(특수 객체를 도입)

2장(의미 있는 이름):

- 분명한 의도
  - **단순하거나 짧다고 분명한 것은 아니다**
  - **이름만 고쳐도 읽기 쉬워진다**
- 그릇된 정보를 피하라
  - 약어 남발 하지 마라
  - 사람들은 이름만 보고 객체를 선택한다
- 구분
  - **빈 칸, 빈 줄도 의미가 있다.**
  - 불용어(noise word) 사용 주의
    - **info, data 등은 너무 흔해서 구분되지 않는다**
- 발음하기 쉽게 하라.
  - 결국 클래스/변수 이름으로 의사소통한다.
- 검색하기 쉬운 이름
  - 상수는 대문자로만
- 암호화 하지 마라
  - 변수 이름을 풀이해야 하는 규칙이 있으면 읽기 어렵다.
  - 헝가리안 표기법은 쓰지 마라! --> IDE로 타입 구분 가능
    - 리팩토링이 활발해지면 변수 타입은 수시로 바뀐다. --> 타입 접두어는 쓸모 없는짓.
- 클래스=명사
- 메소드=동사(구)
- 너무 특이한 이름은 피하라 / 특정문화, 농담, 구어체, 속어
  - **whack --> kill**
- 일관된 용어
  - 하나의 개념에는 하나의 용어
  - 문제 영역 용어(요구사항에서 정의한 용어) 그대로 사용
  - 의미 있는 맥락 추가
    - 맥락에 맞는 접두어 추가
  - 접두어 남용 방지
    - **모든 변수에 접두어를 넣을 생각은 하지 말자.**

3장(함수):

- **함수는 짧게 ; 최대 15줄을 넘기지 말 것**단일 책임 원칙
- - **한가지만 하라**
- 함수 추상화 수준
- - 하나의 수준으로 통일
- 형식
- - 위에서 아래로 읽는 흐름
- switch 문 반복 하지 마라.
- - 다형성 사용
- 서술적 이름
- - 이름에 공을 들여라.
- **인수(argument)는 3개를 넘기지 마라. 3개부터 (타입이 같다면)순서가 헷갈린다**
- - 인수가 많아진다면 캡슐화 할 것최선은 인수가 0개
- 출력 인수는 피하라
- - 차라리 반환 시켜라.
- 플래그 인수는 사용하지 마라
- - 함수 내에서 if-else 처리하는 변수
- 함수(인수) ==> 동사(명사)부수 효과(side effect)를 만들지 마라.
- - 시간적 결합, 순서 종속성 피할 것
- 명령(Command) vs. 조회(Query)

4장(주석):

- 최소! - 없는 것이 가장 좋다.
- 정확! - 있어야 한다면 정확한 정보만
- 법, 정보, 의도, 의미, 경고 제공
- - 어쩔 수 없이 제공해야 하는 것들
- 주절거리는 주석은 없애라

5장(형식 맞추기):

- 빈 행으로 의미 구분하기
- 서로 밀접(호출 관계, 유사성)한 개념은 가까이
- 가로 길이도 최소화
- - 100자 이내로 하자.

6장(객체와 자료 구조):

- 자료 구조 vs. 객체
- - 자료 구조
  - - 메소드 없이 모든 것이 public 변수 인 것: 제한적인 용도로 사용
  - 객체 지향은 기존 코드를 변경하지 않으면서 새로운 개념(자료)를 추가하기 쉽다.
  - 모든 것이 객체라는 것도 미신
  - - 때로는 단순한 자료 구조와 절차적인 코드가 가장 적합할 때가 있음
- 디미터 법칙
- - 사용하는 객체의 속사정(내부 구조)을 알아서는 안된다.
  - 기차 충돌(train wreck)
  - - a().b().c()
    - 주의: fluent interface 개념과는 좀 다르다.
- 자료 구조와 객체를 섞어 쓰지 마라.
- - 양쪽의 단점만
- 객체 근본 주의자들
- - 모든 것을 bean 구조로 만들려고 하는 사람들 --> 실용적이지 않다.
- DTO, ActiveRecord(QIA 참고)
- 자료구조 vs. 객체 절대적인 구분은 없다.
- - 용도에 맞는지 고민 필요

7장(오류 처리):

- 오류 코드가 나쁜 이유
- - if-else 반복으로 인해 코드 가독성을 떨어뜨린다.
  - - 중심 논리(정상 흐름)가 가려짐
- 예외를 잘 쓰자.
- - try-catch-finally 부터
  - - autoclosable 활용하기
    - try() 구문
  - unchecked vs. checked
  - - unchecked를 효율적으로 활용
  - 예외에는 의미가 있어야 함.
  - - 새로운 정보가 추가되지 않는다면 던지지 마라.
  - 외부 라이브러리에서 발생되는 예외는 감싸라
- null 주의
- - null은 주지도 받지도 말자.

8장(경계):

- 외부 코드는 감싸자
- - adapter 패턴
- 학습 테스트 만들기
- - 단위 테스트 프레임워크를 활용
- 깨끗한 경계
- - 인터페이스 정의
  - 외부 라이브러리와의 종속성을 줄이는 방향
- 상속 또는 위임
- 위임이 더 낫다.

9장(단위 테스트):

- TDD 법칙
- - 실패하는 코드 작성 먼저
  - 컴파일만 되는 정도의 테스트 코드 작성
  - 실패하는 코드가 통과 하는 정도만
- 과연 실용적인가? 하루에 구현해야 할 기능이 너무 많다.
- 일회용 테스트는 많이들 작성
- - 단위 테스트는 자동화를 염두에 둔다.
- 단위 테스트 코드도 가독성 높게
- - 중복 제거 -> 리팩토링
- Build-Operate-Check 패턴
- - 잡다함을 제거
  - DSL 구현
  - - 테스트 전용 특수 API
- 이중 표준
- - 코드 vs. 테스트 코드 간 규칙이 상반될 때가 있음
  - - "그릇된 정보를 피하라" 규칙
    - - 지나친 약어, 흡사한 이름 등
      - 테스트에서는 약어로 쓰는게 간명해질 수 있음
    -  
- 주의
- - 테스트 메소드 당 assert는 하나?
  - - 꼭 이러해야 하진 않다.
    - 다양한 관점이 동시에 필요한 경우가 많다.
    - given-when-then 패턴
    - 그러나 최소화 하도록 하자.
- "FIRST" 규칙
- - Fast: 테스트는 빨리 끝날 수 있게
  - Independent: 테스트가 서로 의존하지 않도록
  - Repeatable: 반복 가능하게
  - Self-Validating: 자가 검증
  - - 통과 여부를 log 파일을 통해 확인할 수 있으면 안된다.
  - Timely: 적시에 작성
  - - 메소드 만들 때가 적시

 

10장(클래스):

- SOLID, right-BICEP, CORRECT 원칙 다시 떠올리기. 
- 높은 응집도/낮은 결합도(종속성)
- 형식의 중요성: 변수는 위, 메소드는 서로 쓰이는 것끼리 가까이
- OCP: 확장에는 개방적, 수정에는 폐쇄적
- DIP: 상세한 구현이 아니라 추상화(인터페이스, 메소드 형식)에 의존하게

11장(시스템):

- **추상화: 구체적인 것을 감추고 관심(중심) 분야에 초점**
- 모듈화: 역할을 나눔
- "관심사의 분리"
- 의존성 주입(Dependency Injection) 기법: 제어 역전(Inversion of Control)
- - 의존성은 설정 파일이나 특수 모듈에 명시됨
- 처음부터 완전한 시스템은 없다.
- - 점진적 발전
- 횡단 관심사(cross-cutting)
- - 관점(Aspect)
- 테스트 주도 아키텍처
- - 사용자 스토리에 집중
- 의사 결정 최적화
- - 나중에 결정할 수 있는 구조
- 가능한 "가장 작은" 설계를 사용하라.

 

 

12장(창발성):

-  간명한 설계 원칙
- - 책의 "단순한"은 적합하지 않은 번역 같음
  - 모든 테스트 실행
  - 중복 제거: 리팩토링
  - 의도 표현
  - - 패턴 사용 시 표준 명칭 사용
  - 최소 수의 클래스/메소드
  - - 조건: 단위 테스트

13장(동시성):

- 동시성 필요한 이유
- - 구조 개선: 무엇 vs. 언제
  - 성능 개선: 응답 시간, 처리량(throughput)
- 동시성에 대한 오해
- - 항상 성능이 좋아짐(x)
  - 동시성을 구현해도 설계는 변하지 않는다(x)
  - 프레임워크를 사용하면 원리는 알 필요 없다(x)
- 동시성에 대한 상식
- - 동시성은 부하를 유발
  - 동시성 코드는 복잡
  - 버그 재현 어려움
  - 근본적 설계 전략 필요
- 동시성 방어 원칙
- - 단일 책임 원칙(SRP)
  - - 공유되는 자원(변수)를 줄여라.
    - 그들을 모아서 캡슐화 하라
    - 사본(읽기 전용)으로 사용하라.
    - 스레드 메소드 코드는 독립적으로 작성
    - - 지역 변수만 사용하도록
- 자바 동시성 프레임워크
- - 버전 5 부터 Thread Safe Collection 지원
  - Executor 프레임워크
  - ReentrantLock: 잠그는 메소드와 여는 메소드 분리
  - Semaphore: 카운트가 있는 락
  - CountDownLatch: 쓰레드 동시 시작
- 기본 용어
- - 제한된 자원(Bound Resource):
  - - 책에서는 "한정된 자원"
    - DB connection, buffer 등
    - Thread 간 공유 대상이 됨
  - 상호 배제: 동시에 두 개 이상의 쓰레드에서 사용하지 못하는 경우를 말함
  - 기아: 하나 이상의 쓰레드가 자원 할당을 계속해서 받지 못하는 경우
  - 데드락: 모든 쓰레드가 자원 할당을 받지 못하는 상황
  - 라이브락: 락 거는 단계에서 모든 쓰레드들이 블록킹 되는 상황
- 모델
- - 생산자-소비자: 가장 일반적임,
  - - 제한된 자원(버퍼)를 공유
    - 버퍼가 비워지면 써질 수 있고(생산 가능)
    - 버퍼가 하나라도 채워 있어야 소비가 가능한 구조
    - - 버퍼의 한 요소 별로 소비자 쓰레드가 생성
  - 읽기-쓰기
  - - 소수의 쓰기 쓰레드, 다수의 읽기 쓰레드
    - 갱신(update)를 어떻게 하느냐에 따라 복잡도가 달라짐
- 주의 사항
- - 공유 클래스에 synchronized 메소드가 여러 개인가?
  - - 단일 책임 원칙 어겼을 가능성 높음
  - 동기화 부분 작게
  - 테스트
  - - 다양한 환경: Linux, windows
    - cpu core 수보다 많은 thread 수
    - 보조 코드(instrument): 강제 실패
    - 성능 측정 방법 필요

14장(점진적 개선):

- Args 구현 - 리팩토링
- 한번 쭈욱 따라서 읽어보시길
- 기능 추가 시 바꿔야 할 것이 너무 많은 상황
  - 리팩토링 할 시기
- 점진적 개선
  - 코드를 넣었다 뺐다 하는 상황의 반복
- 단순히 돌아가는데 만족하지 말자
- 처음부터 깨끗하게 유지시키자.
  - 나중에 바꾸려면 힘들다.