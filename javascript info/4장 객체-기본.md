# 객체-기본

## 객체

> 객체는 원시형과 달리 다양한 데이터를 담을 수 있습니다.

```javascript
// 객체 선언
let firstObject = new Object();
let secondObject = {};

// 요소 없애는 법
delete user.age;

// 요소 호출 법
console.log(user.name);
console.log(user["likes birds"]);
let key = "age";
console.log(user[key]);

// 요소 있는 지 확인법
let user = { age: 30 };

let key = "age";
alert(key in user); // true, 변수 key에 저장된 값("age")을 사용해 프로퍼티 존재 여부를 확인합니다.

// 요소 순회
let user = {
  name: "John",
  age: 30,
  isAdmin: true,
};

for (let key in user) {
  // 키
  alert(key); // name, age, isAdmin
  // 키에 해당하는 값
  alert(user[key]); // John, 30, true
}
```

예약어를 키 값으로 사용할 수는 있다. (하지말자)

## 참조에 의한 객체 복사

> 객체와 원시 타입의 근본적인 차이 중 하나는 객체는 `참조에 의해` 저장되고 복사된다는 것이다.

```javascript
let user = { name: "John" };

let admin = user;

admin.name = "Pete";

alert(user.name); // 'Pete' 가 출력됨
```

이렇듯 `참조`를 하고 있어서 비교에서도 다른 상황이 나온다

```javascript
let a = {};
let b = a;
let c = {};

alert(a == b); // true
alert(a === b); // true
alert(a == c); // false
```

그래서 `참조`를 하지 않고 복사를 하고 싶다면 아래와 같이 진행 가능하다

```javascript
// 1번 노가다
let user = {
  name: "John",
  age: 30
};

let clone = {};

for (let key in user) {
  clone[key] = user[key];
}

// 2번 Object.assign (shallow copy 임을 명시해라)
Object.assign(dest, [src1, src2, src3...]); // dest는 목표물, 뒤 어레이는 복사할 객체들이다

let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// permissions1과 permissions2의 프로퍼티를 user로 복사합니다.
Object.assign(user, permissions1, permissions2);

// now user = { name: "John", canView: true, canEdit: true }
// 이미 존재하는 요소가 있으면 덮어씌워지니 조심
let user = {
  name: "John",
  age: 30
};

let clone = Object.assign({}, user);

// 3번 로대쉬의 클론딤 (deep copy) https://lodash.com/docs#cloneDeep
var objects = [{ 'a': 1 }, { 'b': 2 }];

var deep = _.cloneDeep(objects);
console.log(deep[0] === objects[0]);
// => false
```

## 가비지 컬렉션

> 자바스크립트는 눈에 보이지 않는 곳에서 메모리 관리를 수행합니다

global에서 연결된 객체들을 검사하고 연결되지 않은 객체들은 메모리에서 지우는 작업을 진행합니다

- v8과 관련된 링크
- [v8의 가비지 콜렉터](https://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)
- [v8 dev](https://v8.dev/)

## 메서드와 this

> 객체는 값 뿐만이 아니라 함수도 가질 수가 있다

```javascript
// 메서드 만들기 1
let user = {
  name: "John",
  age: 30,
};

user.sayHi = function () {
  alert("안녕하세요!");
};

user.sayHi();

// 메서드 만들기 2
let user = {
  // ...
};

function sayHi() {
  alert("안녕하세요!");
}

user.sayHi = sayHi;

user.sayHi();

// 메서드 만들기 3
user = {
  sayHi: function () {
    alert("Hello");
  },
};

// 단축 구문을 사용하니 더 깔끔해 보이네요.
user = {
  sayHi() {
    // "sayHi: function()"과 동일합니다.
    alert("Hello");
  },
};
```

객체 내부에서 내부를 참조하려면 `this`를 쓰자

```javascript
let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert(this.name);
  },
};

user.sayHi();

// 아래도 가능은 한데 에러가 나올 가능성이 있다. 에러케이스도 보자
let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert(user.name);
  },
};

let admin = user;
user = null; // user를 null로 덮어씁니다.

admin.sayHi(); // Error: Cannot read property 'name' of null
```

화살표 함수의 this는 또 상황이 다르니 추후에 다뤄봅시다

## new 연산자와 생성자 함수

> 사실 객체를 더 편리하게 선언하는 방법은 여러가지가 있습니다

```javascript
// new 연산자를 이용하여
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("보라");

alert(user.name); // 보라
alert(user.isAdmin); // false
```

함수의 빈 return과 new를 합치면 주의해야할 수도 있다

```javascript
function SmallUser() {
  this.name = "원숭이";

  return; // <-- this를 반환함
}

alert(new SmallUser().name); // 원숭이
```
