# 모듈

> 자바스크립트가 점차 커지고 기능도 복잡해져서 모듈 단위로 구성하기 시작했다. 그 시도는 다음과 같은 모듈 시스템으로 이어졌다
>
> - AMD – 가장 오래된 모듈 시스템 중 하나로 require.js라는 라이브러리를 통해 처음 개발되었습니다.
> - CommonJS – Node.js 서버를 위해 만들어진 모듈 시스템입니다.
> - UMD – AMD와 CommonJS와 같은 다양한 모듈 시스템을 함께 사용하기 위해 만들어졌습니다.

## 모듈이란

> 모듈은 단지 파일 하나에 불과합니다.

- `export` 변수나 함수앞에 붙이 면 외부 모듈에서 해당 변수나 함수에 접근할 수 있습니다
- `import` 외뷰 모듈의 기능을 가져올 수 있습니다.

## 모듈의 핵심 기능

- 엄격 모드로 실행됨
- 모듈 레벨 스코프
  - 자신만의 스코프가 있다.
- 단 한 번만 평가됨
  - 내부에서 뭔가 실행시키는 코드가 있다면 import할 때 한번만 실행된다.
- import.meta
  - 스크립트에 대한 정보를 얻을 수 있다
- this는 undefined

## 브라우저 특정 기능

브라우저 환경에서 `type="module"`이 붙은 스크립트가 일반 스크립트와 어떤 차이점이 있을까요?

- 지연 실행
  - 모듈 스크립트는 `항상 지연 실행`됩니다.
  - 모듈 스크립트는 그래서 아래와 같은 특징이 생긴다
    - 외부 모듈 스크립트를 다운로드할 때 브라우저의 HTML 처리가 멈추지 않습니다. 브라우저는 외부 모듈 스크립트와 기타 리소스를 병렬적으로 불러옵니다
    - 모듈 스크립트는 HTML 문서가 완전히 준비될 때까지 대기 상태에 있다가 HTML 문서가 완전히 만들어진 이후에 실행됩니다. 모듈의 크기가 아주 작아서 HTML보다 빨리 불러온 경우에도 말이죠
    - 스크립트의 상대적 순서가 유지됩니다. 문서상 위쪽의 스크립트부터 차례로 실행됩니다.
- 인라인 스크립트의 비동기 처리

  - 비동기적으로 가져오게 처리도 가능
  - ```javascript
    <!-- 필요한 모듈(analytics.js)의 로드가 끝나면 -->
    <!-- 문서나 다른 <script>가 로드되길 기다리지 않고 바로 실행됩니다.-->
    <script async type="module">
    import {counter} from './analytics.js';

    counter.count();
    </script>
    ```

- 외부 스크립트
  - type="module"이 붙으면 아래와 같은 두가지 특징이 있다
    - src 속성값이 동일한 외부 스크립트는 한 번만 실행됩니다
    - 외부 사이트같이 다른 오리진에서 모듈 스크립트를 불러오려면 CORS 챕터에서 설명한 바와 같이 CORS 헤더가 필요합니다. 모듈이 저장되어있는 원격 서버가 Access-Control-Allow-Origin: \* 헤더를 제공해야만 외부 모듈을 불러올 수 있습니다.
- 경로가 없는 모듈은 금지
  - 브라우저 환경에서 `import`는 반드시 상대 혹은 절대 URL앞에 와야합니다.
- 호환을 위한 nomodule

```javascript
<script type="module">
  alert("모던 브라우저를 사용하고 계시군요.");
</script>

<script nomodule>
  alert("type=module을 해석할 수 있는 브라우저는 nomodule 타입의 스크립트는 넘어갑니다. 따라서 이 alert 문은 실행되지 않습니다.")
  alert("오래된 브라우저를 사용하고 있다면 type=module이 붙은 스크립트는 무시됩니다. 대신 이 alert 문이 실행됩니다.");
</script>
```

### 빌드 툴

> 모듈을 단독으로 사용하는 경우는 흔치 않고 [웹팩](https://webpack.js.org/)을 많이 이용합니다

빌드 툴의 역할은 아래와 같습니다

1. HTML의 <script type="module">에 넣을 ‘주요(main)’ 모듈(‘진입점’ 역할을 하는 모듈)을 선택합니다.
2. ‘주요’ 모듈에 의존하고 있는 모듈 분석을 시작으로 모듈 간의 의존 관계를 파악합니다.
3. 모듈 전체를 한데 모아 하나의 큰 파일을 만듭니다(설정에 따라 여러 개의 파일을 만드는 것도 가능합니다). 이 과정에서 import문이 번들러 내 함수로 대체되므로 기존 기능은 그대로 유지됩니다.
4. 이런 과정 중에 변형이나 최적화도 함께 수행됩니다.
   1. 도달 가능하지 않은 코드는 삭제됩니다.
   2. 내보내진 모듈 중 쓰임처가 없는 모듈을 삭제합니다(가지치기(tree-shaking)).
   3. console, debugger 같은 개발 관련 코드를 삭제합니다.
   4. 최신 자바스크립트 문법이 사용된 경우 바벨(Babel)을 사용해 동일한 기능을 하는 낮은 버전의 스크립트로 변환합니다.
   5. 공백 제거, 변수 이름 줄이기 등으로 산출물의 크기를 줄입니다.

## 모듈 내보내고 가져오기

가져올 때는 짧게 가져오는 것을 추천한다. `import asd from './asd.js'` 이유를 알아보자

1. 웹팩같은 모던 빌드툴은 로딩속도를 올리기 위해 번들링과 최적화를 수행합니다.
   1. 만약 asd.js에 asd, qwe, zxc가 있다고 해보자
   2. asd만 import 할 시 qwe, zxc는 번들링될 대 잘려나간다
      1. 트리세이킹
2. 어떤 걸 가져올지 명시하면 이름을 간결하게 할 수 있다
3. 어디서 어떤 게 쓰이는지 명확하기 때문에 코드 구조를 파악하기가 쉬워진다

## 동적으로 모듈 가져오기

### import() 표현식

async 형식으로 이용이 가능하다.

```javascript
let modulePath = prompt("어떤 모듈을 불러오고 싶으세요?");

import(modulePath)
  .then((obj) => {
    "<모듈 객체>";
  })
  .catch((err) => {
    "<로딩 에러, e.g. 해당하는 모듈이 없는 경우>";
  });

let { hi, bye } = await import("./say.js");

hi();
bye();
```
