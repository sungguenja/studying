# 웹 최적화 방식 모음 0,1

[시리즈 시작점 링크](https://black7375.tistory.com/72) 이 글에 대한 리딩을 하려고 한다. 웹 최적화는 중요하다고 생각한다. 굳이 서버에 좀 더 요청을 안보낼 수도 유저의 경험성도 증가시킬 수 있는 것은 중요하다고 생각하기 때문이다.

> 0. 전반적 원칙과 원리
> 1. 다운로드
> 2. 파싱 및 렌더링 트리
> 3. Layout 및 렌더링
> 4. UX 트릭
> 5. 로드후

## 0. 전반적 원칙과 원리

### 네트워크의 동작 순서

1. 브라우저가 DNS 캐시에 도메인이 있는지 확인
2. DNS 캐시에 해당 도메인이 없으면 dns서버에 전달
3. 도메인 확장자를 관리하는 tld 서버에 전달
4. tld 서버는 해당 도메인을 관리하는 dns서버에 요청
5. ip를 전달 받음
6. 브라우저에게 알림
7. 브라우저가 ip주소를 기반으로 요청
8. 해당 도메인에 해당하는 웹페이지 반환

연결의 시작 TCP: 3 way handshake를 이용함을 기억하자

## 브라우저의 동작

1. html 파서와 css파서가 각자 작동
2. html 파서는 dom트리, css파서는 cssom트리 생성
3. 둘을 합체시킨다
4. 렌더트리 형성
5. 그리기
6. 표시

모든 브라우저가 같은 방식은 아니지만 큰 그림은 위와 같다

## 1. 다운로드

응답시간의 80퍼센트는 초기 로딩 부분에서 소요된다. 그 중 대부분이 구성요소의 다운로드에서 소요된다. 그러니 우리는 이 시간을 아낀다면 유저가 경험하는 초기 로딩을 많이 줄일 수가 있다. 크게 3~4단계로 나누어 보자

### 1. 줄이기

용량부터 줄여보자. 다양한 방법이 있을 것이다

1. 디자인 단순화

   디자인이 단순화된다면 다운받아서 보여줄 요소들이 줄을 것이다. 그리고 이러한 것에 권장사항이 당연하게도 있다!!

   - DOM 트리 노드: 1500
   - 최대 깊이: 32
   - 자식 노드를 가지는 부모 노드: 60

   static파일이어도 그 수를 줄이는 것이 방문자에게 체감 속도를 높일 수 있는 좋은 방법이다.

   측정 방법은 `document.getElementsByTagName('*').length`로 간단하게 할 수 있다

   css를 활용하고, 중첩되는 것들을 최대한 줄여보자.

2. 가벼운 라이브러리와 모듈

   기능에 비해 거대한 라이브러리를 쓰는 것을 피하고 필요한 함수만을 이용하도록 하자.

3. 중복 스크립트 제거

   JavaScript파일을 한 페이지에 두번 포함하면 성능이 저하된다. 이러한 구성은 피할 수 있도록 하자. 요즘은 빌드나 관리도구가 발전되어있어서 이러한 것을 하는 것은 잘 안나오긴 하지만 종종 나오니 주의할 수 있도록 하자

4. JS, CSS등 소스 축소

   코드에 불필요한 문제를 제거하여 크기를 줄이고 로드 시간을 개선하는 방법이다. 코드가 축소되면 불필요한 공백문자 뿐만 아니라 모든 주석이 제거된다. JS는 파일 크기도 줄어 응답 시간 성능도 향상된다.

   이쪽 압축기도 좋은게 많으니 자주 이용해볼 수 있도록 하자

5. 웹 폰트 압축 및 서브셋

   [참고 칼람](https://d2.naver.com/helloworld/4969726)

   폰트가 늦게 다운받아지는 것은 꽤 자주 경험해봤을 것이다. 이의 문제점은 폰트에 대한 css요청을 dom이 완성되는 시점에 시작하게 되는데 응답이 돌아오는 타이밍이 cssom트리가 생성되기 직전이면 랜더링이 된다. 하지만 응답이 실패하거나 그 이후에 온다면 랜더링이 느려지거나 실패한다.

   1. 폰트 용량 줄이기

      랜더링할 브라우저에서 지원하는 폰트들'만' 다운받자

      그리고 서브셋을 받을 수 있도록 하자. 현실적으로 갂같은 글자는 랜더링 할 가능성이 매우 낮기 때문이다.

      구글 폰트는 이것을 동작으로 분할 다운받게 해준다고 한다(갓 구글...)

   2. 텍스트가 항상 보이게 하라

      폰트가 아직 오지 않았을 때도 보일 수 있도록 하는 것이 좋다. 아래와 같이 가능하다

      ```css
      body {
          font-family: 'Apple SD Gothic Neo', sans-serif;
      }
      
      body.font-loaded {
          font-family: 'Roboto', 'Apple SD Gothic Neo', sans-serif;
      }
      ```

      

      ```javascript
      var font = new FontFaceObserver('Roboto');
      
      font.load().then(function() {
          document.body.classList.add('fonts-loaded');
      })
      ```

   3. Font Style Matcher로 폰트 간 차이 줄이기

      로드 전과 로드 후의 상황을 최대한 비슷하게 맞출 수 있도록 글자수와 글자 간을 조절하는 방법이다

   4. preload 옵션

6. 이미지 압축

   포맷마다 다양한 방법이 있다.

   - GIF

     [Giflossy](https://www.lcdf.org/gifsicle/) 를 이용해 최적화가 가능

   - PNG

     png는 선택사항이 좀 많다. 품질이 중요하면 [optipng](http://optipng.sourceforge.net/), 용량이 중요하면 [pngquant](https://pngquant.org/)를 이용할 수 있다.

   - JPEG

     [MozJPEG](https://github.com/mozilla/mozjpeg) 이걸 쓰자

7. 이미지, 영상 포맷

   gif와 mp4는 기본적으로 저화질이면 비슷한 느낌이다. 하지만 용량면에서 gif가 mp4의 열배를 보여주는 상황이 자주 나온다. gif를 쓰지 말아야할 이유는 더 많다. 디코딩 성능에서도 문제가 있다. 즉, 우리는 gif를 변환해주는 작업이 있으면 좀 좋다.

   [영상](https://developer.mozilla.org/ko/docs/Web/Media/Formats/Video_codecs) [음성](https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Audio_codecs)

   차근차근 정리해보자

   - GIF

     정적인 gif는 png로 바꾸고 동적이면 mp4, WebM을 써도 좋다

   - WebP

     JPEG보다 25~35%, PNG보다 26% 크기가 작을 정도로 효율적인 이미지 포맷

   - SVG나 CSS

     텍스트로 이루어져있어 큰 폭으로 이미지 크기를 줄일 수가 있다

   - 영상

     하드웨어 가속이 떨어지기 때문에 H.264를 이용해라

     미래에는 효율이 좋아지는 AV1을 이용할 수 있도록 하자. 아직은 하드웨어 가속때문에 좋지는 않다

8. HTML에서 이미지 크기를 조정하지 않기

   해당 부분보다 큰 이미지를 사용하지 말자

   - 커다란 용량으로 다운로드 시간 낭비
   - 대역폭 낭비로 http연결 갯수에 제한
   - 메모리 크기
   - 디코딩 비용
   - 리케일시 비용과 이미지 품질 미보장

   등 다양한 이유가 있다. 굳이 조절해야한다면 [반응형 이미지](https://developer.mozilla.org/ko/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images) 를 이용해보자

9. 파비콘은 가능한 작게

   파비콘을 작게 만드는 것도 최적화에 도움이 된다

10. HTTP 구성요소 압축

    응답 구성요소를 압축하여 줄임으로써 응답 시간을 단축 시킬 수가 있다.

    [Brotli](https://github.com/google/brotli)를 적용시켜보자

11. 클라이언트 힌트로 리소스 선택 자동화

    Accept 헤더를 이용해 브라우저의 컨텐츠 유형을 고르고

    Accept-CH로 클라이언트의 상태나 필요한 것을 서버가 알게 하고

    적절한 것을 돌려주게 하면 된다

12. 구성 요소를 25K 미만으로 유지

    압축되지 않은 크기로 이 크기면 캐시가 되기 마련이다

13. 기타 번들러 최적화

    웹팩/바벨 등의 최적화를 다루자

요청을 줄일 수도 있다

1. DNS 조회 감소

   DNS 조회 정보가 캐싱된다. 호스트 구성 요소를 2~4개로 적절히 분리통합하고 유지하자

2. CDN 사용

   웹 서버에 대한 사용자의 근접성은 응답 시간에 영향을 준다.

   잘 분산된 CDN을 이용하자

3. 404 피하기

   http요청은 많은 비용이 든다. 그러니 404자체를 피할 수 있도록 하자

4. 서명된 교환

   SXG 캐시를 사용해 콘텐츠를 미리 가져오는 성능 개선을 생각해볼 수가 있다

5. 서버 응답 시간 개선

   로직의 최적화를 항상 생각해라

6. 기타 네트워크 최적화

   이건 네트워크 근간 이야기이다. 극한의 최적화가 필요하면 잘 해보자

## 2. 합치기

요청을 줄이는 것이 핵심이라면 줄이기는 연장선이다.

1. 파일 결합하기

   script, css파일을 합쳐서 요청 횟수를 줄이는 것

2. css sprites

   이미지 요청 수를 줄이기 위해 나온 기법

   이건 논의할 거리가 조금 있긴 하다. 필요시 투입하는게 좋다

3. image maps

   여러 이미지를 단일 이미지로 결합하여 http 요청 수를 줄인다는 아이디어. 그런데 이건 좀 좌표에 대한 오류를 일으킬 가능성이 있다. 이것은 있다고만 알고 넘어갈 수 있도록 하자

4. 인라인 인코딩

   바이너리로 하드 코딩?

   스프라이트 하기 힘든 작은 아이콘들에 적용하는 것이 좋다

5. 다중 문서에 구성요소들을 묶기

   HTTP 한 요청에 다 보낸다면 비용들이 추가발생하지 않을 수 있다

   하지만 현재 의미있는 기술은 아니다

## 3. 나누기

크기가 크거나 모듈화나 캐싱이 가능한 것은 나누는 것이 좋다.

1. 도메인 별로 구성요소들을 분리
2. JavaScript와 css를 외부로 두기

