# The Two Pillars of JavaScript

[칼럼 링크](https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3)

초반부 생략 ㅎㅎ

자바스크립트는 언제나 가장 중요한 언어중 하나이다. 하지만 두가지 패러다임을 대중화시켜버렸다. 프로그래밍의 진화에 있어서 극도로 중요한 패러다임들이다.

- Prototypal Inheritance (Objects Linking to Ohter Objects라고도 불림)
- Functional Programming

난 이것들을 자바스크립트의 두 기둥들이라고 부르고 싶다. 그리고 나는 그들이 나를 망쳤다는 것을 부끄러워하지 않는다.

자바스크립트는 만들어진 이래로 가장 영향력 있는 언어라고 기억될 것이다. 많은 다른 언어들이 이 두 기둥들에서 많은 것을 복사해온다. 그리고 이 기둥들은 애플리케이션을 쓴느 방식에 또는 다른 언어들에 다양한 방법으로 바뀌었다.

`~~중략~~`

자 이제 래밸업 해보자!

## 우리는 거대한 덩어리를 만들어야 한다.

> 어둠속을 걷는다는 것을 인지못하는 자는 빛을 찾을 수 없다 - 브루스 리 (이지선다 젭라...)

컨스트럭터들은 모든 호출자와 객체가 인스턴스화되는 방법에 대한 세부정보를 연결하기위해 개방 폐쇄 원칙을 어긴다. HTML5 게임을 만드나? 새 객체 인스턴스로부터 객체 풀을 쓰기 위해 바꾸길 원한다면 너는 객체를 재활용해야하며 가비지 컬랙터를 멈춰야 한다. 매우 거지같다. 너는 모든 호출자를 부셔버릴것이며, 또는 너는 hobbled 팩토리 함수와 함께 끝날 것이다.

만약 당신이 컨스트럭터 함수에게서 임의의 객체를 받는다면, 당신의 프로토타입 링크를 부술것이며 `this`는 더이상 엮이지 않을 것이다. 이것은 유연성이 실제 함수보다 떨어진다. 왜냐하면 당신은 이제 `this`를 모든 함수에서 이용할 수 없다!

스트릭트모드에서 돌아가지 않는 컨스트럭터들은 위험해 처할 수도 있다. `new`호출자를 잊고 당신이 스트릭트 모드 또는 ES6 클레스들을 사용하지 않는다면.  당신이 선언하는 `this`들은 전역 네임스페이스에 오염될 것이다. 그리고 그것은 못생겼다.

이 언어는 버그를 찾기 매우 어려운 언어다. 자바스크립트에서 팩토리 함수는 `new`요구사항을 뺀 컨스트럭터 함수일 뿐이다. 전역 오염은 위험하고 한계가 있다

자바스크립트는 함수가 객체를 반환할 수 있어서 컨스트럭터 함수를 필요로 하지 않는다. 동적 객체 확장에 있어서 ,객체 리터럴과 `Object.create()`, 우리는 우리가 필요한 모든 것을 가지고 있다.

## 지옥의 일곱번째 자리에 온 것을 환영한다

> 꽤 자주 나는 그렇게 비참하지 않다 현명할 수 있는 만큼 비참하지는 않다. - T.H. White

모두 끓인 개구리에 대해 들었을 것이다. 끓고있는 물에 개구리를 던지면 그것은 튀어 오르지만 차가운 물에 넣고 점진적으로 증가시킨다면 개구리는 익어버릴 것이다. 자 이제 우리는 개구리다

컨스트럭터의 행동은 달궈진 팬이라면 클래시컬한 상속은 불없는 것과 같다. 단테의 일곱번째 지옥에서 온 불같으니라고

클래시컬한 상속은 일반적으로 단일 조상에게서 상속받게 할 것이다. 그리고 어색한 분류법을 강요할 것이다. 실패를 빼기위한 강요는 내가 봐온 큰 어플리케이션에서 모든 객체 지향적 디자인 분류법은 보통 틀렸다.

###  Fragile 기반 클래스 문제  (레아세두 이쁨)

자식 클래스와 그것의 부모를 커플링하는 것은 객체지향 디자인에서 가장 타이트한 형태중 하나다. 그리고 이것은 재사용 가능한 모듈식 코드와는 정반대에 있다.

작은 변화는 완벽히 관련없는 것같은 부서진 것들같은 베이스 클래스들의 리플링 사이드 이펙트를 만들 것이다.

### 필요 문제에 의한 중복

분류학 문제에 있어서 뻔한 해결법으로 돌아갈 타임이다. 상속받는 것을 변화시켜 미묘한 차이를 가진 새 클래스를 구축하라. 하지만 이것은 적절하게 추출하고 반영하게 하기 위해 너무 타이트하게 엮여버렸다. 당신은 재사용 하는 대신에 복제해버렸다. 당신은 DRY원칙을 어겼다. (다 어겨버린다 에헤헤헤헤)

결과로써 당신은 당신의 클래스들의 미묘한 차이 정글을 지속적으로 성장시켰을 것이며 당신의 클랫들은 점점 더 관절염적이며 연약해질 것이다. 그리고 당신이 버그를 발견한 때, 너는 그자리에서 고치지 않을 것이다. 너는 모든 장소를 고쳐야 할것이다. (정말 끔찍한 상황이군)

이것은 고전적인 객체지향 프로그래밍에서 자주 나오는 문제이다. 피해야 하지만..... ES6 클레스들은 이러한 문제점을 고치지 않았다. ES6는 더 안좋게 만들었다. 왜냐하면 그들의 나쁜 아이디어는 스펙에 축복을 내려왔으며 많고 많은 책들과 블로그 포스트에 의해 쓰여졌다.

`class` 키워드는 이제 자바스크립트에게 harmful한 형태이다. 나는 스텐다제이션 효과를 위해 기여하는 천재들과 열심히 일하는 노동자들에게 엄청난 리스팩트를 가지고 있다. 하지만 심지어 천재 인간들 조차 가끔 잘못된 짓을 한다. 1과 2를 더할려고 해보자. 너의 브라우저 콘솔에서. 나는 여전히 웹, 프로그래밍 언어, 컴퓨터 사이언스에 엄청난 기여를 해온 Brendan Eich를 생각한다.

`super`좀 그만 써

### 폴아웃 ~~누카콜라 주세용~~ ~~볼트회전~~

이러한 문제들은 당신의 어플리케이션이 성장함에 따라 영향을 키워가고  단 하나의 솔루션은 어플리케이션을 다시 쓰는 것인 상황이 와버린다.

난 이러한 프로세스를 아주 많이 보고 또 보고 보고 또 보고볻바고니아러ㅗ ㅁ니ㅏㄹㅇ호미ㅏ;ㄱ소;ㅏㄴㄷㅅㄱ

내가 다녔던 회사에서는 재작성을 위해 소프트웨어를 일년 늦췄다! 나는 업데이트를 믿었지 재작성을 ㅁ믿지 않았다. 또다른 회사에서는 회사가 망하는 원인이 되기 까지 했다.

## 빛으로 가보자

> 더 이상 추가할 것이 없을 때가 아니라 뺄 것이 없을 때 완벽에 도달한다.

요즘 나는 거의 대부분 함수에 의존하며 모듈은 행동과 데이터 구조를 정의하기 위한 객체 컴포지션의 변수 폼을 나누기 위해 임포트한다. 나는 일반적 함수와 추상적 데이터 타입을 이용하며 exposing없이 데이터를 조종하기 위해 직접적으로 데이터 구조와 접속한다

spread syntax를 이용해 객체의 속성을 복사하거나 확장하는 것도 할 수 있따.

복사 메커니즘은 프로토타입적인 속성의 또다른 형태이다. 속성 복사의 속성들은 exemplar prototypes라고 불리는 프로토타입의 특별한 종류중 하나이다 그리고 exemplar prototype을 복사하는 것은 concatenative 상속으로 알려져 있다.

concatenative 상속은 동적 객체 확장(객체가 인스턴스화 되고 추가가 가능한 기능)이라는 자바스크립트의 기능으로 인해 가능하다.

당신은 자바스크립트의 클레스들이 거의 필요하지 않고 exporting된 api를 제어하고 있다면 클래스가 대안보다 더 좋은 접근 방법인 상황을 나는 본 적이 없다.

내가 컨스트럭터와 고전적 상속이 나쁘다고 사람들에게 말할때 그들은 방어를 한다. *나는 당신을 공격하지 않아요 당신을 도울려는거에요*

##  좋은 코드는 심플하다

간단한 세개를 가지고 가자

- 간단하게 하려고 해라. (더 쉽게 읽고 더 쉽게 써라.)
- 유연성을 더 가져라. (객체 풀을 재활용하기 위한 새 인스턴스를 교체해라)
- 파워풀하고 더 비싸게 하라

