# micro frontend

[마이크로 프론트엔드란?](https://mobicon.tistory.com/572)  [넷플릭스의 경우](https://netflixtechblog.com/how-we-build-micro-frontends-with-lattice-22b8635f77ea) [Lattice js](https://www.latticejs.com/)

개념자체는 어렵지 않다. 작은 단위로 나눠서 개발후 통합하는 방식을 마이크로 프론트앤드라고 할 수 있으며 애자일 방식에서 잘 이용한다. 그렇다면 장단점이 무엇이 있을까

- 장점

  - 작고, 응집력있고 유지보수성을 가지는 코드베이스
  - 분리배포의 용이
  - 자율적인 팀 조직 운영의 수월
  - 프론트 앤드 개발을 점진적으로 업그레이드 또는 리빌딩이 수월

- 단점

  - 배포 번들이 커질 수 있음
  - 개발 환경의 차이가 생길 수 있음
  - 운영 및 거버넌스도 복잡

- 통합 방법

  - 서버 템플릿 통합

    각 서버로 html 템플릿을 요청하고, 최종 응답서버에서 각 템플릿을 조합해서 응답을 보냄

    서버측에서 최종 화면을 조합한다

  - 빌드 타임 통합

    단위 애플리케이션을 패키지로 배포, package.json에 명시 후 컨테이너 애플리케이션에서 import하여 사용하는 방법

    각 애플리케이션 런타임에 대응이 안됨

    애플리케이션을 릴리즈하고 최종 애플리케이션에서 컴파일 해야 함

  - iframe 통합

    전통적이며 쉬움

    유연성이 높고 종속성이 없다

    rouing, history, deep-link같은 것이 복잡

    통신규약도 필요하고 ux가 iframe안에 갇혀 ui가 이상해질 수 있음

  - javascript를 통한 런타임 통합

    iframe과 달리 유연한 통합이 가능하고 가장 많이 사용되는 방식

    컨테이너 애플리케이션을 단위 애플리케이션 번들을 `<script>` 태그를 통합 다운로드

    약속된 초기화 메소드 호출

    클라에서 브라우져 통합

  - web component를 통한 통합

    html 커스텀 엘리먼트를 통한 통합방법, static, runtime 통합 둘 다 가능

- 고려 사항

  - ui 일관성
  - 앱간의 통신은 custom event를 사용
  - 백앤드 호출 api구성

넷플릭스도 위와같은 방식으로 했다고 최근에 말을 했다. 그러면 한번 넷플릭스의 마이크로 프론트엔드를 한번 살펴보자(글을 토대로)

급격한 진화를 위해 추상화를 잘할 필요가 있다고 한다. 이것은 나도 중요하다고 생각한다. 클린 아키텍쳐에 따르면 추상화의 정도와 경계선을 잘 나누는 것이 좋은 아키텍쳐라고 했었던 기억이 있다. (클린 아키텍처 다시 정리할 필요가 있을 듯 하다)

## 우리의 툴에 대한 다른 접근

- 아래와 같은 접근법을 이용해서 고수준의 객체를 이끌 수가 있다고 한다

  - 저 마찰 체택

    기존 프론트 엔드 코드를 재사용하도록 권장하며 UI 기능을 캡슐화하는 새 패키지를 만들지 말아라. 패키지 간에 기능을 공유해야 하는 경우 애플리케이션을 관리하기 어려울 수 있습니다. 애플리케이션이 공통적이고 익숙한 반응 패러다임을 사용하여 핵심 기능을 확장할 수 있는 접근 방식을 활용할 수 있습니다.

  - 약한 종속성

    호스트 응용 프로그램은 https프로토콜을 통해 netflix 내부적으로 호스팅되는 원격 번들을 참조 가능한다.

  - 고도로 정렬되며 느슨하네 결합

    netflix에서 사용되는 표준 프레임워크 및 라이브러리와 완전히 일치. 플러그인은 불필요한 상용구 없이 핵심 기능을 제공하는데 초점을 맞추고 번거로운 API 포장지 없이 구현할 수 있어야 한다.

  - 메타데이터 기반

    플러그인 모듈은 애플리케이션 라이프사이클의 어느 지점에서나 주입될 수 있는 구성에서 정의해야한다.

  - 신속한 개발

    불필요한 빌드 및 배포를 방지하여 개발 주기를 단축. TS를 적극 사용하면서 견고한 인터페이스로 설계하여 플로그인과 호스트를 동시에 개발하자

## 이론적 예제

![](https://miro.medium.com/max/2000/1*N4vhCT7uQ4T3bxXQcc6kug.gif)

위 예시를 보면 이것은 헤더와 콘텐트를 렌더링 하고 컨트롤한다. 릴리스된 이후에, 우리는 나이스하다는 피드백을 받을것이다. Lattice Plugin Host는 우리가 플러그인, workflows, spinnaker 을 참고하여 앱을 확장하는 것을 도와준다. 넷플릭스의 예에서는, 우리는 확장할 두가지 공간을 정할때 - 포탈 컴포넌트와 구성가능한 라우팅을 위한 어플리케이션 콘텐츠

위의 렌더링 프로세스를 수행하기 위한 이벤트들의 순서는 3 컴포넌트들에 의해 이루어진다. 새로운 프레임워크 Lattice와 두 플러그인에 의해서

![](https://miro.medium.com/max/588/1*oATisPnWoUtW7IVihj1Ibw.gif)

1. Lattice는 비동기적으로 두 플러그인을 로드한다
2. 프레임워크는 이벤트를 발생시킬 것이다
3. 우리의 예에서는 workflows가 라우터를 등록하며 spinnaker는 오버레이를 추가할 것이다

## 리액트에서의 도입

위 시나리오를 이루기 위해서, Host 어플리케이션은 Lattice라이브러리를 포함할 필요가 있으며 외부 플러그인을 참조하는 구성으로 새로운 `PluginHost` 를 추가할 필요가 있다. 호스트는 특정 어플리케이션에 대한 정보와 로드할 플러그인을 나타내는 구성을 필요로 하다.

위와 같은 예를 우리는 `useFetchPluginConfiguration`훅과 함께 추가적인 서비스로부터 메타데이터를 받기위해 구현을 모킹했습니다. 소유자는 플러그인을 동적으로 추가하거나 제거할 수 있습니다. 어플 소스코드 외부에서 말이죠

라우팅에 접근하는 플러그인을 허락하는 것은 lattice 프레임워크로 정해진 훅을 사용하는 것으로 진행이 될 수 있다. `usePluggableState` 훅은 디폴트 어플리케이션 라우트를 회수할 것이며 lattice framework를 통과해서 지나갈 것이다. 만약 어떠한 플러그인도 `AppRoutes` 아이덴티파이어에 응답한다면, 그들의 특정 라우트에 대해 inject할 것을 선택할 수 있다

## 후드 아래에서

> Lattice는 react웹 애플리케이션이 활용할 수 있는 추상화 계층을 제공하는 작은 프레임워크입니다.

Lattice를 사용하면, 개발자들은 그들의 코어 상품에 집중할 수 있고, 간단하게 추가 플러그인으로 인해 커스터마이징 가능한 그들의 어플리케이션 공간을 감쌀 수가 있다. 개발자는 컴포넌트를  추가적인 상태를 사용하기 위해 확장할 수 있다

![](https://miro.medium.com/max/681/1*WCgMzUkEdKH9bfz3jWzEww.png)

...생략 (이유는 Lattice에 대한 설명이 대부분이어서)

## 가능성은 끝이 없다

원래 우리의 접근 방식은 애플리케이션 내에서 핵심 기능을 확장하는 것이었지만, 우리는 다른 방법으로 Lattice를 활용할 수 있다는 것을 알게 되었다. 만약 진술이 대체되었다면 간단히 작성한다는 개념; 우리는 한 걸음 물러서서, 우리 조직에서 어떤 영역이 해당 논리에 책임을 져야 하는지를 고려하고 논리를 각각의 플러그인으로 옮기는 것을 고려합니다.

또한 애플리케이션 내에서 보다 세분화된 영역을 쉽게 모델링할 수 있다는 사실도 알아냈습니다. 예를 들어, Lattice 식별자를 사용하여 개별 양식 구성요소를 랜더링할 수 있으며 플러그인이 특정 UI 요소를 담당하도록 할 수 있습니다. 이를 통해 메타데이터 모델과 기본 즉시 사용 환경을 지원하는 것을 구축할 수 있다.

