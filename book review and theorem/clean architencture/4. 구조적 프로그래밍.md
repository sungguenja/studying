# 4. 구조적 프로그래밍

> 1. 증명
> 2. 해로운 성명서
> 3. 기능적 분해
> 4. 엄밀한 증명은 없었다
> 5. 과학이 구출하다
> 6. 테스트 결론

데이크스트라가 제안한 구조적 프로그래밍은 처음 도입(처음 개념화된 프로그래밍 패러다임은 아니다)되었다. 이 시기에는 진공관 시대였고 느리며, 쉽게 손상되는 상태였고 생각보다 좋은 상황은 아니었고 이런 상황에서 결과를 얻기 위해 고안되었던 기법이고 위대한 발견을 해낸 것이다.

## 1. 증명

데이크스트라가 인식한 문제는 `프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘 못한다`라는 사실이었다. 단순할지라도 인간의 두뇌로 감당하기에는 너무 많은 세부사항이 있었다.

데이크스트라는 증명이라는 수학적인 원리를 적용하여 이 문제를 해결하고자 했다. 즉, 수학에서 이미 입증된 구조를 프로그래머들이 이용할려는 방식을 요구했다. 이렇게 하려면 단순한 알고리즘에 대해 기본적인 증명을 작성할 수 있는 기법을 보여줘야 한다는 사실을 깨달았다. 그러나 이 연구는 상당히 힘들어 보였다.

`goto`문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견했다. 모듈을 분해를 할 수 없다면 분할 정복을 할 수가 없기 때문에 이것은 문제였다. 그런데 반대로 `goto` 문장을 사용하더라도 모듈을 분해할 때 문제가 되지 않는 경우도 있었다. 이런 경우의 좋은 사용의 경우 if/else, do/while 등을 단순한 제어 구조에 해당하는 사실을 발견했다. 세분화하는 것이 가능해 보였다.

그는 이러한 제어 구조는 순차 실행과 결합했을 때 특별하다는 사실을 깨달았다. 이러한 제어 구조는 순차, 분기, 반복 이라는 세가지 구조만으로 표현할 수 있다는 사실을 증명했다.

이 발견으로 모듈을 증명 가능하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실을 증명하게 되었고 이것이 구조적 프로그래밍의 탄생이었다.

- 분기

  데이크스트라는 열거법을 재적용하는 방식으로 처리했다. 먼저 분기를 통한 각 경로를 열거했다. 두 경로가 수학적으로 적절한 결과를 만들어낸다면, 증명은 신뢰할 수 있게 된다.

- 반복

  이것의 올바름은 귀납법을 이용했다.

이러한 증명은 고되고 복잡했지만, 증명은 증명이었다.

## 2. 해로운 성명서

데이크스트라는 goeo문의 해로운에서 세가지 제어 구조에 대한 자신의 의견을 피력했다. 이에 대해 그때 당시 만흥 논란이 있었고 10년이상 지속되었지만 결국 스일는 데이크스트라의 것이었다. 컴퓨터 언어가 진화하면서 goto문장은 뒤편으로 밀려났고, 사라졌다.

우리 모두는 현재 구조적 프로그래머이며, 여기에는 선택의 여지가 없다. 제어흐름을 제약 없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문이다.

## 3. 기능적 분해

우리는 이제 모듈을 기능적으로 분해할 수 있게 되었다. 즉, 거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있다. 그리고 이들 각 기능은 다시 저수준의 함수들로 분해할 수 있고, 이러한 분해 과정을 끝없이 반복할 것이다.

이를 토대로 **구조적 분석**이나 **구조적 설계**와 같은 기법이 1980년대까지 인기가 있었다. 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있었다.

## 4. 엄밀한 증명은 없었다.

하지만 끝내 증명은 이루어지지 않았다. 수학적인 증명으로는 이를 구출하진 못했다. 하지만 **과학적인 방법**이 우리를 다시 일으켜줬다

## 5. 과학이 구출하다

과학적 방법은 입증은 반증은 가능하지만 증명은 불가능하다. 하지만 우리는 모두 이것을 믿고 행한다. 우리는 이것이 사실임을 증명하는 방식이 아니라 서술이 틀렸음을 증명하는 방식으로 동작한다.

## 6. 테스트

데이크스트라는 "테스트는 버그가 있음을 보여줄 뿐 버그가 없음을 보여줄 수는 없다"고 말한 적이 있다. 프로그램이 잘못되었음은 테스트로 증명이 가능하지만 옳은 것은 증명이 불가능 하다는 것이다.

## 7. 결론

구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 바로 이 능력 때문이다. 가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 반증 가능성에 의해 주도해야한다.