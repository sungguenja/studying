# 15. 아키텍처란?

> 1. 개발
> 2. 배포
> 3. 운영
> 4. 유지보수
> 5. 선택사항 열어 두기
> 6. 장치 독립성
> 7. 광고 우편
> 8. 물리적 주소 할당
> 9. 결론

What is Software Architecture? 무엇일까? 무슨 일을 하고 언제 그 일을 하길래 존경심을 불러일으키는 위인이 떠오르는 단어가 된 것인가?

무엇보다 일단 프로그래머이다. 코드에서 탈피하여 고수준의 문제에 집중하는 것이 아니다. 오히려 코드와 동떨어지면 안될 것이다. 코드를 덜 작성할 수는 있다. 그러나 진정으로 생각해야하는 것은 **팀원들의 생산성이 극대화할 수 있는 설계를 하도록 방향을 인도하는 방법이다**.

`소프트웨어 시스템의 아키텍처 == 시스템을 구축했던 사람들이 만들어낸 시스템의 형태` 컴포넌트로 분할하고 분할된 컴포넌트를 배치하고 컴포넌트가 의사소통하는 방식이다. 그리고 이러한 형태를 기반으로 개발, 배포, 운영, 유지 보수가 용이하도록 하는 것이다.

주된 목적은 시스템의 생명주기를 지원한다고 생각해도 괜찮다. 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 또 쉽게 배포하게 해준다.

## 1. 개발

시스템 아키텍처는 개발팀(들)이 시스템을 쉽게 개발할 수 있도록 뒷받침해야만 한다.

그런데 팀 구조가 다르다면 이 결정에 관한 관점도 차이가 난다. 실제로 다들 많이 겪어봤을 것이다. 일례로 개발자 인원이 다섯명정도로 작다면 그들은 잘 정의된 컴포넌트, 인터페이스를 이용하기 보다 서로 효율적으로 대화하며 개발할 것이다. 그리고 이러한 팀에서 일을 할 경우 오히려 이런 정의는 제약처럼 느껴지고 방해로 생각이 될 것이다.

다른 경우를 보자 조금 대인원이 있는 경우이다. 시스템을 신뢰할 수 있는 안정된 인터페이스를 갖춘, 잘 설계된 컴포넌트 단위로 분리하지 않으면 개발이 진행이 아예 안 될 것이다. 그리고 그 안에서도 각 팀별로 컴포넌트가 발전할 것이다. 이런 경우에 팀별 단일 컴포넌트라고 명명한 것이 최적일 가능성은 0다. 그럼에도 일정때문에 결국 이 아키텍처를 이용할 것이다.

그러니 우리는 팀과 개발전체에 있어서 아키텍처에 대한 정의가 필요할 것이다.

## 2. 배포

배포 비용이 높을 수록 시스템의 유용성은 매우 떨어질 것이다. 따라서 우리는 쉽게 배포가 가능한 소프트웨어에 목표를 두어야 한다.

하지만 안타깝게도 많이 경험해봤겠지만 초기 개발 단계에서 배포 전략을 고려하는 경우는 거의 없다. 이로인해 배포 전까지 개발이 수비다가 배포에서 어려워지는 상황이 종종 발생한다.

'마이크로서비스 아키텍처'를 사용하자고 결정해보자. 이 접근법을 사용하면 컴포넌트 경계가 매우 뚜렷해지고 인터페이스가 대체로 안정화된다. 그 결과 개발이 매우 쉬울 것이다. 그러나 배포할 시기가 되면 위험해진다. 서로 연결하고 작동 순서를 결정하는 과정에서 오작동이 발생할 원천이 스며들 수가 있다!

## 3. 운영

운영에 미치는 영향은 그래도 위 두가지와 유지보수에 미치는 것보다는 덜 극단적이다. 단순히 하드웨어를 더 투입하거나 업그레이드로 해결하는 경우도 많이 볼 수가 있다.

비효율적이라 저장량이 많은데 이러한 경우 그저 스토리지와 서버를 추가하는 것으로 제대로 동작하게 할 수가 있다. 하드웨어의 비용이 인력보다는 싼 경우가 많기 때문이다.

물론 운영을 쉽게 해주는 아키텍처는 훌륭한 아키텍처이다. 다만 비용적인 관점에서 운영보다는 개발, 배포, 유지보수 쪽에 더 영향이 큰 것은 사실이다. 그리고 우리는 그래도 잘 설계하는 것이 좋다. 좋은 소프트웨어 아키텍처는 운영시 필요한 요구도 쉽게 알 수 있기 때문이다.

## 4. 유지보수

유지보수는 모든 측면에서 봤을 때 소프트웨어 시스템에서 비용이 가장 많이 든다. 새로운 기능은 언제나 추가하고 싶어지며 그에 따른 결함은 피할수없고 ~~I AM INEVITABLE~~ 그리고 이 결함을 수정하기 위해 또 비용이 투자될 것이다.

유지보수에서는 탐사(Spelunking) ~~깨시조아~~와 그로 인한 위험부담에 있다. 탐사란 새 기능을 추가하거나 결함을 수정할 때, 소프트웨어의 어디를 고치는 것이 최선인지, 어떤 전략을 쓰는게 최적일지 고민하는 행위이며 당연히 비용이 발생한다. 그리고 이것은 의도치 않은 결함은 반드시 나온다.

주의를 기울인 신중한 아키텍처는 이 비용을 크게 줄이는데 아주 큰 도움이 된다. 시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 격리시킨다. 이를 통해 미래에 새로운 가능성을 열어두고 의도치 않은 장애가 발생할 위험을 줄일 수가 있다.

## 5. 선택사항 열어 두기

`소프트웨어 == 행위적 가치 + 구조적 가치`, 구조적 가치는 매우 중요하다 소프트웨어를 얼마나 소프트(깔깔깔)하게 만들 수 있는가가 이 가치에 달려있다. 그리고 이 소프트한 정도(이하 유연성)은 시스템의 형태, 컴포넌트 배치 방식, 컴포넌트가 상호 연결되는 방식에 의존한다.

그러니 우리는 이 유연성을 유지시키기 위한 방법은 가능한 한 많이, 가능한 한 오래 열어둬야 한다. 그렇다면 뭐를 열어둬야하는데? 뭣이 중한디? 그것은 바로 중요치 않은 세부사항(detail)이다.

모든 소프트웨어는 두가지 구성요소로 분해할 수 있다. `정책(policy)`와 `세부사항`이다. 정책은 시스템의 진정한 가치가 살아 있는 곳이다.

세부사항은 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소지만, 정책이 가진 행위에는 조금도 영향을 미치지 않는다. 세부사항에는 입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등등이 있다.

아키텍트의 목표는 정책을 가장 핵심적인 요소로 식별하고, 세버사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는 데에 있다. 예를 보자

- DB 시스템을 선택할 필요가 없다! 고수준의 정책은 어떤 종류의 데이터베이스를 사용하는지 신경 쓰지 않는다! 어떠한 데이터베이스 시스템인지 정책은 신경쓸 필요도 없고 관련도 없다
- 웹 서버를 선택할 필요가 없다. 고수준의 정책은 자신이 웹을 통해 전달된다는 사실조차 몰라야 한다.
- 등등

요점을 파악하자. 세부사항에 몰두하지 말고 고수준의 정책을 만들어라. 그러면 세부사항에 대한 결정을 오랫동안 미루거나 연기할 수가 있다. 이런 결정을 더 오래 참을 수 있다면 더 많은 정보를 취득할 수도 있고 이것들이 좋은 기초가 되어 성공적인 결정을 도출할 수가 있다.

또한 이러한 지식이 다양한 선택지도 열어줄 것이다. 다른 DB를 이용해본다거나 다양한 웹 시스템, 프레임워크 등 다양한 것을 도입하고 시도해볼 것이다.

> 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다

## 6. 장치 독립성

구시대적 코드를 생각해보자. 경험한 적 없는 코드들이다. 프린터로 인쇄할 일이 있다면, 해당 프린터를 제어하는 입출력 명령어를 직접 사용해서 코드를 작성해야 한다. 그리고 이러한 코드는 장치 종속적이 될 것이다.

어떠한 면에서는 효과적인 전략일 수가 있다. 하지만 프로그래머들은 후에 이것이 실수였다는 것을 깨달았다. 해당 장치가 사라진다면 대체할 수 있는 장치는 없다! 그 장치가 고스란히 와줘야한다는 뭄ㄴ제점이 있따.

60년대 후반에 이르고 이 문제를 생각해서 장치 독립성을 생각했다. 장치를 함수로 추상화하고, 프로그램은 서비스를 호출하고, 오퍼레이터가 추상 서비스를 어디에 연결해야하는지 운영체제에게 알려주었다

## 7. 광고 우편

장치 독립성을 생각하면 어떠한 장치가 오든 적절한 대응이 가능해진다. 장치가 어떤 것이 오는지 중요하지 않게 처리가 가능하다

## 8. 물리적 주소 할당

디스크의 직접적인 레코드를 탐색하는 코드를 짰다고 해보자. 그러면 디스크를 추가하거나 다른 디스크로 교체되는 순간 모든 코드를 갈아야할 것이다. 상대주소를 이용해서 코드를 짠다면 이러한 문제점이 없을 것이다. 즉, 상대주소를 이용하여 장치 독립성을 올린 것이다.

## 9. 결론

광고 우편과 물리적 주소 할당에서 봐온 예들이 소규모 사례이지만 다양한 곳에서 이런 문제를 겪는 곳이 있을 것이다. 세부사항에 대한 결정은 최대한 미룰 수 있는 방향으로 정책을 설계할 수 있도록 하자.
