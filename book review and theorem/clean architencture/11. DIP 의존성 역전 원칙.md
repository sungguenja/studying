# 11. DIP: 의존성 역전 원칙

> 1. 안정된 추상화
> 2. 팩토리
> 3. 구체 컴포넌트
> 4. 결론

동적이든 정적이든 어떤 언어든 이 아이디어, 이 규칙을 적용하자. 구체적인 대상에는 절대로 의존하지 말 것. (사실 동적은 무엇이 구체 모듈인지 정의하기 어렵다) 이 아이디어는 꽤 비현실적이다. 소프트웨어 시스템은 무조건 구체적인 장치에 의존해야만 하며 String도 구체 클래스이며 다양하다.

다양한 이유로 DIP를 논할 때는 운영체제나 플랫폼 같이 안정성이 보장된 환경은 무시하는 편이다. 즉, String같은 당연한 것이나 소프트웨어 시스템의 경우같은 것은 무시하라는 것이다. 우리가 의존하지 않도록 피하는 것은 변동성이 큰 구체적인 요소이다

## 1. 안정된 추상화

추상 인터페이스 변경이 생기면 이를 구체화한 구현체들도 따라서 수정해야 한다. 반대로 구체적인 구현체에 변경이 생기더라도 그 구현체가 구현하는 인터페이스는 항상, 좀 더 정확히 말하면 대부분 변경될 필요가 없다. 즉, 인터페이스는 구현체보다 변동성이 낮다

실제로 뛰어난 아키텍트와 설계자는 인터페이스의 변동성을 낮추기 위해 애쓴다. 인터페이스를 변경하지 않고 구현체에 기능을 추가할 방법을 찾으려고 하며 이것이 설계의 기본이다. 즉, 안정된 소프트웨어 아키텍처는 변동성이 큰 구현체에 의존성을 줄이고 안정된 추상 인터페이스를 선호하는 것이다. 요약하면 다음과 같다

- 변동성이 큰 구체 클래스를 참조하지 말라: 대신 추상 인터페이스를 참조하라
- 변동성이 큰 구체 클래스로부터 파생하지 말아라.
- 구체 함수를 오버라이드 하지 말아라.
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라(~~볼드모트?~~)

## 2. 팩토리

위 규칙을 준수하려면 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 한다. 그리고 이건 매우 당연하다. 구체적인 코드에 대해 의존성이 발생하기 때문이다.

이러한 것을 피하기 위해 추상 팩토리를 사용하곤 한다.추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함한다. 구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 모든 세부사항을 포함한다. 그리고 **제어흐름은 언제나 소스 코드 의존성과는 정반대 방향으로 흐른다는 점을 주목하자**. 

## 3. 구체 컴포넌트

DIP위배를 모두 없앨 수는 없다. 하지만 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과 분리할 수가 있다.

## 4. 결론

이 원칙은 계속해서 등장할 것이다. 그러니 머릿속에 박아두고 읽으면서 계속 생각할 수 있도록 해보자