# 02장 리액트 핵심 요소 깊게 살펴보기

> 1. 리액트의 모든 훅 파헤치기
> 2. 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야할까

## 1. 리액트의 모든 훅 파헤치기

> 리액트 함수 컴포넌트에서 가장 중요한 개념은 바로 훅이다.
>
> 훅은 클래스 컴포넌트에서만 가능했던 state, ref 등 리액트의 핵심적인 기능을 함수에서도 가능하게 만들었고, 무엇보다 클래스 컴포넌트보다 간결하게 작성할 수 있어 후기 등장한 이래로 대부분의 리액트 컴포넌트는 함수 컴포넌트로 작성되고 있을 정도로 많은 사랑을 받고 있다

1. useState
   - 리액트에서 훅을 언급할 때 가장 먼저 떠올리는 것
   - `const [state, setState] = useState(initialState)`
   - useState는 클로저의 형태로 구현되어 있을 것이다
   - 게으른 초기화
     - useState에 변수 대신 함수를 넘기는 것을 게으른 초기화라고 한다
     - 리액트 공식 문서에서 게으른 초기화는 useState의 초깃값이 복잡하거나 무거운 연산을 포함하고 있을 떄 사용하라고 돼 있다
     - 리액트에서는 랜더링이 실행될 때마다 함수 컴포넌트의 함수가 다시 실행된다는 점을 명심해야한다
2. useEffect
   - 리액트 코드를 작성할 때 useState만큼이나 자주 쓰는 후기 바로 useEffect
   - 첫 번째 인수로는 실행할 부수 효과가 포함된 함수를, 두 번째 인수로는 의존성 배열을 전달한다
   - 의존성 배열이 변경될 때마다 useEffect의 첫 번째 인수인 콜백이 실행된다
   - 랜더링 과정에서 실행되는 부수 효과 함수
   - 클린업 함수
     - useEffect내에서 반환되는 함수는 클린업 함수라 불린다. (useEffect에서 return에 넣는 함수)
     - 클린업 함수는 이전 상태를 참조한다.
     - 클린업 함수는 비록 새로운 값을 기반으로 렌더링 뒤에 실행되지만 이 변경된 값을 읽는 것이 아니라 함수가 정의했을 당시에 선언했던 이전 값을 보고 실행된다는 것이다.
   - 의존성 배열
     - 의존성 배열은 보통 빈배열을 두거나, 아예 아무런 값도 넘기지 ㅇ낳거나, 혹은 사용자가 직접 원하는 값을 넣어줄 수 있다.
     - 그러면 값을 아예 안넣는 거랑 그냐 useEffect를 안 쓰는 거랑 같지 ㅇ낳나?
       - 서버 사이드 렌더링 관점에서 useEffect는 클라이언트 사이드에서 실행되는 것을 보장해준다. useEffect내부에서는 window ㄱ개체의 접근ㅇ에 의존하는 코드를 사용해도 된다
       - useEffect는 컴포넌트 렌더링의 부수 효과, 즉 컴포넌트의 렌더링이 완료된 이후에 실행된다. 반면 함수 내부에서의 직접 실행은 컴포넌트가 렌더링되는 도중에 실행된다.
     - 주의점
       - eslint-disable-line react-hooks/exhaustive-deps 주석은 최대한 자제하자
       - useEffect의 첫번째 인수에 함수명을 부여하라
       - 거대한 useEffect를 만들지 마라
       - 불필요한 외부 함수를 만들지 마라
