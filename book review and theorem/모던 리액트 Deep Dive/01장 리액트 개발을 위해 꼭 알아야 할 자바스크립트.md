# 01장 리액트 개발을 위해 꼭 알아야 할 자바스크립트

> 0. 왜 리액트인가? 리액트의 역사
> 1. 자바스크립트의 동등 비교
> 2. 함수
> 3. 클래스
> 4. 클로저
> 5. 이벤트 루프와 비동기 통신의 이해
> 6. 리액트에서 자주 사용하는 자바스크립트 문법
> 7. 선택이 아닌 필수, 타입 스크립트

## 0. 왜 리액트인가? 리액트의 역사

- 리액트가 전자정부 표준 프레임워크 프론트엔드 개발 도구로 채택될 정도의 시대가 와버렸다.
- 리액트는 지금 넘사의 인기이다

## 1. 자바스크립트의 동등 비교

> 리액트 함수 컴포넌트와 훅을 반복적으로 작성하다 보면 의존성 배열에 대해 고민해 본 적이 있을 것이다.
>
> 리액트의 가상 DOM과 실제 DOM의 비교, 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다.
>
> 자바스크립트의 이러한 동등 비교는 어떻게 수행되는지, 또 이를 리액트에서 어떻게 활용하고 있는지 살펴보자.

1. 자바스크립트의 데이터 타입
   - 원시 타입
     - undefined
       - 선언한 후 값을 할당하지 않은 변수 또는 값이 주어지지 않은 인수에 자동으로 할당되는 값
       - undefined 타입은 undefined 값만 가질 수 있다
     - null
       - 아직 값이 없거나 비어 있는 값을 표현할 대 사용한다
       - `typeof null` 을 하면 object로 반환된다
     - Boolean
       - true, false 만을 가질 수 있는 데이터 타입이다
       - 조건문에서 많이 쓰인다
       - boolean값처럼 조건문에서 사용되는 `truthy`, `falsy`값이 존재한다
         - falsy: 조건문 내부에서 false로 취급되는 값
           - | 값           | 타입           | 설명                                    |
             | ------------ | -------------- | --------------------------------------- |
             | false        | Boolean        | false는 대표적인 falsy                  |
             | 0,-0,0n,0x0n | Number, BigInt | 0은 부호나 소수점 유무에 상관없이 falsy |
             | NaN          | Number         | Number가 아니라는 것을 뜻하며 falsy     |
             | '',"",``     | String         | 빈 문자열                               |
             | null         | null           |                                         |
             | undefined    | undefined      |                                         |
         - truthy: 조건문 내부에서 true로 취급되는 값.
     - Number
       - 정수와 실수를 구분해 저장하는 다른 언어와 다르게 JS는 모든 숫자를 하나의 타입에 저장했다
       - 진수에 대해서도 별도 데이터 제공을 하지 않아 십진수와 비교해도 비교처리를 해준다
     - BigInt
       - 앞서 number가 다룰 수 이는 숫자 크기의 제한을 그복하기 위해 ES2020에서 새롭게 나온다
       - 일반적인 number는 한계 이상의 숫자는 비교가 이상하게 된다 (ex: `9007199254740992 === 9007199254740993` 요건 true가 된다)
       - BigInt로 지정하려면 `const testInt = 9007199254740992n` 또는 `const testInt = BigInt('9007199254740992')` 를 쓰면 된다
     - String
       - string은 텍스트 타입의 데이터를 저장하기 위해 사용된다.
     - Symbol
       - 중복되지 않는 어떠한 고유한 값을 나타내기 위해 만들어졌다.
       - 심벌은 심벌 함수를 이용해서만 만들 수 있다
   - 객체 타입
     - object
       - 객체 타입을 간단하게 정의하면 앞서 7가지 원시 타입 이외의 모든 것
       - 배열 함수 정규식 클래스 등이 포함
2. 값을 저장하는 방식의 차이

   - 원시 타입과 객체 타입의 가장 큰 차이점
   - 원시 타입은 불변 형태로 저장된다
   - 반면 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달하게 된다

     ```javascript
     const hello = "hello world";
     const hi = hello;
     console.log(hello === hi); // true

     const hello2 = "hello world";
     const hi2 = "hello world";
     console.log(hello2 === hi2); // true

     const hello3 = { greet: "hello, world" };
     const hi3 = { greet: "hello, world" };
     console.log(hello3 === hi3); // false
     console.log(hello3.greet === hi3.greet); // true
     ```

   - 크롬 개발자 도구를 열어보면 객체의 참조가 다름을 확인할 수 있다

3. 자바스크립트의 또 다른 비교 공식, Object.is

   - `==`과 차이
     - `==` 기뵤는 같음을 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환을 한 후에 비교한다
     - 하지만 Object.is는 이러한 작업을 하지 않고 타입이 다르면 그냥 false를 반환한다
   - `===`과 차이

     - 값의 세부까지 비교해준다.

       ```javascript
       -0 === +0; // true
       Object.is(-0, +0); // false

       Number.NaN === NaN; // false
       Object.is(Number.NaN, NaN); // true

       NaN === 0 / 0; // false
       Object.is(NaN, 0 / 0); // true
       ```

   - 그리고 객체 비교에 있어서는 원리가 동일해서 위에 적어둔 객체 비교처럼 흘러간다

4. 리액트에서의 동등 비교
   - Object.is로 동작한다
