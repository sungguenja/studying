# 01장 리액트 개발을 위해 꼭 알아야 할 자바스크립트

> 0. 왜 리액트인가? 리액트의 역사
> 1. 자바스크립트의 동등 비교
> 2. 함수
> 3. 클래스
> 4. 클로저
> 5. 이벤트 루프와 비동기 통신의 이해
> 6. 리액트에서 자주 사용하는 자바스크립트 문법
> 7. 선택이 아닌 필수, 타입 스크립트

## 0. 왜 리액트인가? 리액트의 역사

- 리액트가 전자정부 표준 프레임워크 프론트엔드 개발 도구로 채택될 정도의 시대가 와버렸다.
- 리액트는 지금 넘사의 인기이다

## 1. 자바스크립트의 동등 비교

> 리액트 함수 컴포넌트와 훅을 반복적으로 작성하다 보면 의존성 배열에 대해 고민해 본 적이 있을 것이다.
>
> 리액트의 가상 DOM과 실제 DOM의 비교, 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다.
>
> 자바스크립트의 이러한 동등 비교는 어떻게 수행되는지, 또 이를 리액트에서 어떻게 활용하고 있는지 살펴보자.

1. 자바스크립트의 데이터 타입
   - 원시 타입
     - undefined
       - 선언한 후 값을 할당하지 않은 변수 또는 값이 주어지지 않은 인수에 자동으로 할당되는 값
       - undefined 타입은 undefined 값만 가질 수 있다
     - null
       - 아직 값이 없거나 비어 있는 값을 표현할 대 사용한다
       - `typeof null` 을 하면 object로 반환된다
     - Boolean
       - true, false 만을 가질 수 있는 데이터 타입이다
       - 조건문에서 많이 쓰인다
       - boolean값처럼 조건문에서 사용되는 `truthy`, `falsy`값이 존재한다
         - falsy: 조건문 내부에서 false로 취급되는 값
           - | 값           | 타입           | 설명                                    |
             | ------------ | -------------- | --------------------------------------- |
             | false        | Boolean        | false는 대표적인 falsy                  |
             | 0,-0,0n,0x0n | Number, BigInt | 0은 부호나 소수점 유무에 상관없이 falsy |
             | NaN          | Number         | Number가 아니라는 것을 뜻하며 falsy     |
             | '',"",``     | String         | 빈 문자열                               |
             | null         | null           |                                         |
             | undefined    | undefined      |                                         |
         - truthy: 조건문 내부에서 true로 취급되는 값.
     - Number
       - 정수와 실수를 구분해 저장하는 다른 언어와 다르게 JS는 모든 숫자를 하나의 타입에 저장했다
       - 진수에 대해서도 별도 데이터 제공을 하지 않아 십진수와 비교해도 비교처리를 해준다
     - BigInt
       - 앞서 number가 다룰 수 이는 숫자 크기의 제한을 그복하기 위해 ES2020에서 새롭게 나온다
       - 일반적인 number는 한계 이상의 숫자는 비교가 이상하게 된다 (ex: `9007199254740992 === 9007199254740993` 요건 true가 된다)
       - BigInt로 지정하려면 `const testInt = 9007199254740992n` 또는 `const testInt = BigInt('9007199254740992')` 를 쓰면 된다
     - String
       - string은 텍스트 타입의 데이터를 저장하기 위해 사용된다.
     - Symbol
       - 중복되지 않는 어떠한 고유한 값을 나타내기 위해 만들어졌다.
       - 심벌은 심벌 함수를 이용해서만 만들 수 있다
   - 객체 타입
     - object
       - 객체 타입을 간단하게 정의하면 앞서 7가지 원시 타입 이외의 모든 것
       - 배열 함수 정규식 클래스 등이 포함
2. 값을 저장하는 방식의 차이

   - 원시 타입과 객체 타입의 가장 큰 차이점
   - 원시 타입은 불변 형태로 저장된다
   - 반면 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달하게 된다

     ```javascript
     const hello = "hello world";
     const hi = hello;
     console.log(hello === hi); // true

     const hello2 = "hello world";
     const hi2 = "hello world";
     console.log(hello2 === hi2); // true

     const hello3 = { greet: "hello, world" };
     const hi3 = { greet: "hello, world" };
     console.log(hello3 === hi3); // false
     console.log(hello3.greet === hi3.greet); // true
     ```

   - 크롬 개발자 도구를 열어보면 객체의 참조가 다름을 확인할 수 있다

3. 자바스크립트의 또 다른 비교 공식, Object.is

   - `==`과 차이
     - `==` 기뵤는 같음을 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환을 한 후에 비교한다
     - 하지만 Object.is는 이러한 작업을 하지 않고 타입이 다르면 그냥 false를 반환한다
   - `===`과 차이

     - 값의 세부까지 비교해준다.

       ```javascript
       -0 === +0; // true
       Object.is(-0, +0); // false

       Number.NaN === NaN; // false
       Object.is(Number.NaN, NaN); // true

       NaN === 0 / 0; // false
       Object.is(NaN, 0 / 0); // true
       ```

   - 그리고 객체 비교에 있어서는 원리가 동일해서 위에 적어둔 객체 비교처럼 흘러간다

4. 리액트에서의 동등 비교
   - Object.is로 동작한다

## 2. 함수

1. 함수란?
   - 작업을 수행하거나 값을 계산하는 드으이 과정을 표현하고
   - 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것
   - 리액트에서 컴포넌트를 만드는 함수도 가능하다
   - 함수는 `일급 객체`이다
     - `일급 객체`란? 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다
2. 함수를 정의하는 4가지 방법
   1. 함수 선언문
      - 가장 일반적인 방법
        ```javascript
        function add(a, b) {
          return a + b;
        }
        ```
   2. 함수 표현식
      - 함수는 일급 객체이므로 변수에 할당하는 것은 당연하다
        ```javascript
        const sum = function (a, b) {
          return a + b;
        };
        ```
      - 함수 표현식에서는 할당하려는 함수의 이름을 생략하는 것이 일반적이다
      - 함수 선언문과의 차이
        - 호이스팅 여부
        - 선언문은 호이스팅이 되므로 코드 위에서 호출해도 호출이 된다
        - 하지만 표현식은 그렇지 않다
   3. Function 생성자
      - 일반적인 방법은 아니긴 하다
        ```javascript
        const add = new Function("a", "b", "return a + b");
        ```
   4. 화살표 함수
      - `=>` 라는 화살표를 활용해서 만드는 함수
      - 화살표 함수는 constructor을 사용할 수가 없다
      - arguments도 존재하지 않는다
      - 그리고 일반 함수와 가장 큰 차이점은 this 바인딩이다
3. 다양한 함수 살펴보기
   - 즉시 실행 함수
     - 함수를 정의하는 순간 바로 실행하는 함수
     - `(function(a,b){return a + b})(10, 24)`
   - 고차 함수
     - 함수를 인수로 받거나 결과로 새로운 함수를 반환시키는 함수
4. 함수를 만들 때 주의해야할 사항
   - 함수의 부수 효과(side-effect)를 최대한 억제하라
   - 가능한 한 함수를 작게 만들어라
   - 누구나 이해할 수 있는 이름을 붙여라

## 3. 클래스

1. 클래스란?
   - 특정한 객체를 만들기 위한 일종의 템플릿과 같은 개념
   - 추상화하는데 아주 편하다
   - constructor
     - constructor는 생성자로, 객체를 생성하는데 사용하는 특수한 메서드
     - 단 하나만 존재할 수 있으며, 여러 개를 사용하면 에러가 발생한다
   - property
     - 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값
   - getter, setter
     - getter는 클래스에서 무언가 값을 가져올 때
     - setter는 값을 할당할 때
   - 인스턴스 메서드
     - 클래스 내부에서 선언한 메서드를 인스턴스 메서드라고 한다
   - 정적 메서드
     - 특이하게 인스턴스가 아닌 클래스 자체로 호출하는 메서드
2. 클래스와 함수의 관계
   - 클래스 작동은 생성자 함수로 매우 유사하게 재현할 수 있다
