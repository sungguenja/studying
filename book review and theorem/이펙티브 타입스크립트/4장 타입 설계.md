# 4장 타입 설계

> 누가 순서도를 보여 주면서 테이블을 감추면 나는 여전히 갸우뚱할 것이다. 하지만 테이블을 보여 준다면 순서도는 별로 필요하지 않다. 보지 않더라도 명백할 것이기 때문이다.

## 아이템 28 유효한 상태만 표현하는 타입을 지향하기

> 타입을 잘 설계하면 코드는 직관적으로 작성할 수 있습니다. 그러나 타입 설계가 엉망이라면 어떠한 기억이나 문서도 도움이 되지 못합니다.

웹 애플리케이션을 만든다고 가정해보자. 애플리케이션에서 페이지를 선택하면, 페이지의 내용을 로드하고 화면에 표시해야하며 상태는 아래와 같이 설계한다. 그리고 render를 위한 함수도 같이 작성해보자

```typescript
interface State {
  pageText: string;
  isLoading: boolean;
  error?: string;
}

function renderPage(state: State) {
  if (state.error) {
    return `Error! Unable to load ${currentPage}: ${state.error}`;
  } else if (state.isLoading) {
    return `Loading ${currentPage}...`;
  }
  return `<h1>${currentPage}</h1>\n${state.pageText}`;
}
```

근데 이런 상황이면 로딩중이고 에러값도 있는 상황에 대한 표시가 되질 않는다. 필요한 정보가 부족하기 때문이다! 한편 페이지 전환하는 함수는 아래와 같이 짰다.

```typescript
async function changePage(state: State, newPage: string) {
  state.isLoading = true;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }
    const text = await response.text();
    state.isLoading = false;
    state.pageText = text;
  } catch (e) {
    state.error = "" + e;
  }
}
```

- 위 코드의 문제점
  - 오류가 발생했을 때 state.isLoading을 false로 설정하는 로직이 빠져있다
  - state.error를 초기화하지 않아서 전환도중 과거의 오류 메시지가 보일 것
  - 페이지 로딩 중에 사용자가 페이지를 바꿔 버리면 어떤 일이 벌어질지 예상이 어렵다.

종합적으로 문제가 많은 코드들이 되었다. 조금 더 제대로 표현해볼 수 있도록 해보자

```typescript
interface RequestPending {
  state: "pending";
}
interface RequestError {
  state: "error";
  error: string;
}
interface RequestSuccess {
  state: "ok";
  pageText: string;
}
type RequestState = RequestPending | RequestError | RequestSuccess;

interface State {
  currentPage: string;
  requests: { [page: string]: RequestState };
}

function renderPage(state: State) {
  const { currentPage } = state;
  const requestState = state.requests[currentPage];
  switch (requestState.state) {
    case "pending":
      return `Loading ${currentPage}...`;
    case "error":
      return `Error! Unable to load ${currentPage}: ${requestState.error}`;
    case "ok":
      return `<h1>${currentPage}</h1>\n${requestState.pageText}`;
  }
}

async function changePage(state: State, newPage: string) {
  state.requests[newPage] = { state: "pending" };
  state.currentPage = newPage;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }
    const pageText = await response.text();
    state.requests[newPage] = { state: "ok", pageText };
  } catch (e) {
    state.requests[newPage] = { state: "error", error: "" + e };
  }
}
```

네트워크 요청도 명시적이며 무효한 상태를 허용하지 않게 되었고 모든 요청의 상태로서 명시적으로 모델링 되었다. 그리고 각 함수의 모호함은 완전히 사라졌으며 무효가된 요청에 대해서도 UI에 영향이 없다.

- 요약
  - 유요한 상태와 무효한 상태를 둘 다 표현하는 타입은 혼란을 초래하기 쉽고 오류를 유발하게 됩니다
  - 유효한 상태만 표현하는 타입을 지향해야 합니다. 코드가 길어지거나 표현하기 어렵지만 결국은 시간을 절약하고 고통을 줄일 수 있습니다
