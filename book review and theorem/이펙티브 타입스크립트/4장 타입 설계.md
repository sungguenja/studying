# 4장 타입 설계

> 누가 순서도를 보여 주면서 테이블을 감추면 나는 여전히 갸우뚱할 것이다. 하지만 테이블을 보여 준다면 순서도는 별로 필요하지 않다. 보지 않더라도 명백할 것이기 때문이다.

## 아이템 28 유효한 상태만 표현하는 타입을 지향하기

> 타입을 잘 설계하면 코드는 직관적으로 작성할 수 있습니다. 그러나 타입 설계가 엉망이라면 어떠한 기억이나 문서도 도움이 되지 못합니다.

웹 애플리케이션을 만든다고 가정해보자. 애플리케이션에서 페이지를 선택하면, 페이지의 내용을 로드하고 화면에 표시해야하며 상태는 아래와 같이 설계한다. 그리고 render를 위한 함수도 같이 작성해보자

```typescript
interface State {
  pageText: string;
  isLoading: boolean;
  error?: string;
}

function renderPage(state: State) {
  if (state.error) {
    return `Error! Unable to load ${currentPage}: ${state.error}`;
  } else if (state.isLoading) {
    return `Loading ${currentPage}...`;
  }
  return `<h1>${currentPage}</h1>\n${state.pageText}`;
}
```

근데 이런 상황이면 로딩중이고 에러값도 있는 상황에 대한 표시가 되질 않는다. 필요한 정보가 부족하기 때문이다! 한편 페이지 전환하는 함수는 아래와 같이 짰다.

```typescript
async function changePage(state: State, newPage: string) {
  state.isLoading = true;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }
    const text = await response.text();
    state.isLoading = false;
    state.pageText = text;
  } catch (e) {
    state.error = "" + e;
  }
}
```

- 위 코드의 문제점
  - 오류가 발생했을 때 state.isLoading을 false로 설정하는 로직이 빠져있다
  - state.error를 초기화하지 않아서 전환도중 과거의 오류 메시지가 보일 것
  - 페이지 로딩 중에 사용자가 페이지를 바꿔 버리면 어떤 일이 벌어질지 예상이 어렵다.

종합적으로 문제가 많은 코드들이 되었다. 조금 더 제대로 표현해볼 수 있도록 해보자

```typescript
interface RequestPending {
  state: "pending";
}
interface RequestError {
  state: "error";
  error: string;
}
interface RequestSuccess {
  state: "ok";
  pageText: string;
}
type RequestState = RequestPending | RequestError | RequestSuccess;

interface State {
  currentPage: string;
  requests: { [page: string]: RequestState };
}

function renderPage(state: State) {
  const { currentPage } = state;
  const requestState = state.requests[currentPage];
  switch (requestState.state) {
    case "pending":
      return `Loading ${currentPage}...`;
    case "error":
      return `Error! Unable to load ${currentPage}: ${requestState.error}`;
    case "ok":
      return `<h1>${currentPage}</h1>\n${requestState.pageText}`;
  }
}

async function changePage(state: State, newPage: string) {
  state.requests[newPage] = { state: "pending" };
  state.currentPage = newPage;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }
    const pageText = await response.text();
    state.requests[newPage] = { state: "ok", pageText };
  } catch (e) {
    state.requests[newPage] = { state: "error", error: "" + e };
  }
}
```

네트워크 요청도 명시적이며 무효한 상태를 허용하지 않게 되었고 모든 요청의 상태로서 명시적으로 모델링 되었다. 그리고 각 함수의 모호함은 완전히 사라졌으며 무효가된 요청에 대해서도 UI에 영향이 없다.

- 요약
  - 유요한 상태와 무효한 상태를 둘 다 표현하는 타입은 혼란을 초래하기 쉽고 오류를 유발하게 됩니다
  - 유효한 상태만 표현하는 타입을 지향해야 합니다. 코드가 길어지거나 표현하기 어렵지만 결국은 시간을 절약하고 고통을 줄일 수 있습니다

## 아이템 29 사용할 때는 너그럽게, 생성할 때는 엄격하게

> TCP 구현체는 경고성의 일반적 우너칙을 따라야 한다. 당신의 작업은 엄격하게 하고, 다른 사람의 작업은 너그럽게 받아들여야 한다.

3D 매핑 API는 카메라의 위치를 지정하고 경계 박스의 뷰포트를 계산하는 방법을 제공한다. 그러니 아래와 같이 만들어보자

```typescript
declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): CameraOptions; //  요 결과물이 setCamera로 바로 전달될 수 있다면 편리할 것이다.

interface CameraOptions {
  center?: LngLat;
  zoom?: number;
  bearing?: number;
  pitch?: number;
}
type LngLat =
  | { lng: number; lat: number }
  | { lon: number; lat: number }
  | [number, number];
type LngLatBounds =
  | { northease: LngLat; southwest: LngLat }
  | [LngLat, LngLat]
  | [number, number, number, number];
```

일부 값을 건들지 않으면서 동시에 다른 값 설정도 필요하므로 `CameraOptions`의 모든 필드는 옵셔널이다. 그리고 `LngLat`도 범위가 넓어야 한다. 넓게 다양한 경우를 생각한다면 이렇게 넓은 타입이 될 것이다. 뷰포트를 조절하고, 새 뷰포트를 url에 저장하는 함수를 작성해보자

```typescript
function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  const {
    center: { lat, lng },
    zoom,
  } = camera; // 'lat','lng' 속성이 없다는 에러 발생
  zoom; // 타입이 number | undefined
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```

viewportForBounds의 타입 선언이 사용될 때 뿐만 아니라 만들어질 때에도 너무 자유로운 문제로 인해 속성이 없다는 에러가 일어날 것이다. 수많은 선택적 송성을 가지는 반환 타입과 유니온 타입은 viewportForBounds를 사용하기 어렵게 만든다.매개변수 타입의 범위가 넓으면 사용하기 편리하지만, 반환 타입의 범위가 넓으면 불편하다. 즉, `사용하기 편리한 API일수록 반환 타입이 엄격해야한다`

유니온 타입의 요소별 분기를 위한 한가지 방법은, 좌표를 위한 기본 형식을 구분하는 것이다.

```typescript
interface LngLat {
  lng: number;
  lat: number;
}
type LngLatLike = LngLat | { lon: number; lat: number } | [number, number];

interface Camera {
  center: LngLat;
  zoom: number;
  bearing: number;
  pitch: number;
}
interface CameraOptions extends Omit<Partial<Camera>, "center"> {
  center?: LngLatLike;
}
type LngLatBounds =
  | { northease: LngLatLike; southwest: LngLatLike }
  | [LngLatLike, LngLatLike]
  | [number, number, number, number];

declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): Camera;
```

위와 같이 인풋에 대한 타입은 넓게 아웃풋에 대한 타입은 타이트하게 만들 수도 있고 우리가 만들었던 `focusOnFeature` 함수도 정상 동작 할 것이다.

```typescript
function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  const {
    center: { lat, lng },
    zoom,
  } = camera;
  zoom; // 타입이 number
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```

- 요약
  - 보통 매개변수 타입은 반환 타입에 비해 범위가 넓은 경향이 있습니다. 선택적 속성과 유니온 타입은 반환 타입보다 매개변수 타입에 더 일반적입니다
  - 매개변수와 반환 타입의 재사용을 위해서 기본 형태(반환 타입)와 느슨한 형태(매개변수 타입)를 도입하는 것이 좋습니다.
