# 2장 타입스크립트의 타입 시스템

> 타입스크립트는 코드를 자바스크립트로 변환하는 역할
>
> **타입 시스템**이 무엇보다 중요
>
> 기초부터 살펴보자

## 아이템 6 편집기를 사용하여 타입 시스템 탐색하기

타입스크립트를 설치하면 아래 두가지가 사용가능

> 1. 타입스크립트 컴파일러
> 2. 단독으로 실행할 수 있는 타입스크립트 서버

타입스크립트 서버에서 편집기를 이용한다면 그만큼 타입을 익히기 쉬운 것이 없다 아래 코드들은 자동으로 타입추론이 된다!! (심지어 리턴값 마저도)

```typescript
let num = 10; // num타입을 number로 인지함

function add(a:number, b:number) {
  return a+;
} // vscode에서 add함수에 마우스를 올리면 리턴값도 넘버로 추정하는 것을 확인 가능하다.

function logMessage(message: string | null) {
  if (message) {
    return message
  }
  return null
} // 안쪽 message를 string으로 인지한다.
```

위에서 확인 가능하듯이 반대로 타입을 명시적으로 적어 에러를 확인할 수 도 있다. 편집기 상의 타입오류를 살펴보는 것도 타입 시스템의 성향을 파악하는데 도움이 된다. 아래 코드는 두 곳에서 오류를 발생시킨다.

```typescript
function getElement(elOrId: string | HTMLElement | null): HTMLElement {
  if (typeof elOrId === "object") {
    return elOrId; // HTMLElement | null 형식은 HTMLElement 형식에 할당할 수 없습니다
  } else if (elOrId === null) {
    return document.body;
  } else {
    const el = document.getElementById(elOrId);
    return el; // HTMLElement | null 형식은 HTMLElement 형식에 할당할 수 없습니다
  }
}
```

위 코드의 오류를 잡기 위해서는 `처음에 object에 null의 가능성도 있어 null체크를 추가하는 것` 그리고 `document.getElementById도 null이 가능하다!`. 혹시 문서확인이 필요하다면 vscode에서는 정의로 이동 옵션도 제공한다!!

- 요약
  - 편집기에서 타입스크립트 언어 서비스를 적극 활용해라
  - 편집기를 사용하면 어떻게 타입시스템이 동작하는지, 그리고 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있다
  - 타입스크립트가 동작을 어떻게 모델링하는지 알기 위해 타입 선언 파일을 찾아보는 방법을 터득해야한다

## 아이템 7 타입이 값들의 집합이라고 생각하기

JS는 어떠한 값이든 할당이 가능하다. 하지만 실행전, 타입스크립트가 오류를 체크하는 순간에는 `타입`이 존재한다. 이러한 상태에서 우리는 거꾸로 타입을 `할당 가능한 값들의 집합`이라고 생각하면 된다. 이와 같이 생각할 수 있는 대표적인 예는 `유닛 타입`이다.

```typescript
type A = "A";
type B = "B";
type Twelve = 12;
type AB = "A" | "B";
type AB12 = "A" | "B" | 12;
const a: AB = "123"; // 에러 발생
const b: AB12 = 12; // 정상 작동
declare let twelve: AB12;
const back: AB = twelve; // 에러 발생
```

위 코드는 직접 실행시켜보고 확인해보자. 위 코드를 보면 집합의 의미가 더 와닿을 것이다. 그리고 집합의 개념으로 `interface`도 존재한다

```typescript
interface Identified {
  id: string;
}

interface Person {
  name: string;
}

interface Lifespan {
  birth: Date;
  death?: Date;
}

type PersionSpan = Person & Lifespan;

type K = keyof (Person | Lifespan); // K는 never와 같아짐

interface Vector1D {
  x: number;
}
interface Vector2D extends Vector1D {
  y: number;
}
interface Vector3D extends Vector2D {
  z: number;
}
// Venctor2D는 1D의 부분집합, 3D는 2D의 부분집합으로 생각해도 된다

function getKey<K extends string>(val: any, key: K) {
  // K 타입은 string의 부분집합이 된다
  //...
  return key;
}

getKey({}, "x");
getKey({}, Math.random() < 0.5 ? "A" : "B");
getKey({}, 12); // 12는 number라 'string'형식의 매개변수에 할당 불가
```

위 코드가 슬슬 이해가 된다면 궁극적으로 `객체의 키 타입을 반환하는 keyof T`를 이해하기 수월해진다.

```typescript
interface Point {
  x: number;
  y: number;
}

type PointKeys = keyof Point;
function sortBy<K extends keyof T, T>(vals: T[], key: K): T[] {
  // ...
}

const pts: Point[] = [
  { x: 1, y: 1 },
  { x: 2, y: 0 },
];
sortBy(pts, "x"); // 정상, 'x'는 'x'|'y'를 상속
sortBy(pts, "y");
sortBy(pts, Math.random() < 0.5 ? "x" : "y");
sortBy(pts, "z"); // 에러
```

아래 코드는 신기한 에러가 보일 것이다. 한번 탐구해보자

```typescript
const list = [1, 2];
const tuple: [number, number] = list; // number[]타입은 [number,number] 타입의 0,1 속성에 없습니다. 타입을 반대로 하면 의외로 작동한다.
const triple: [number, number, number] = [1, 2, 3];
const double: [number, number] = triple; // [number,number,number]형식은 [number,number] 형식에 할당할 수 없습니다. length속성의 형식이 호환되지 않습니다. '3' 형식은 '2' 형식에 할당할 수 없습니다.
```

위는 타입스크립트가 숫자의 쌍을 할당하는 방식을 보면 흥미롭다. 쌍을 {0:number, 1: number, length: 2}로 할당을 했다. 그래서 **length, 3**형식의 말이 나오는 것이다

- 요약
  - 타입은 값의 집합으로 생각하자.
  - 타입스크립트 타입은 엄격한 상속관계가 아니라 겹쳐지는 집합으로 표현된다
  - 한 객체의 추가적인 속성이 타입 선언에 언급되지 않아도 속할 수 있다.
  - 타입 연산은 집합의 범위에 적용된다.
  - 집합형식으로 생각하면 이해가 어렵지 않다

## 아이템 8 타입 공간과 값 공간의 심벌 구분하기

```typescript
// 혼란스럽겠지만 의외로 아래 코드는 이름 중복같은 에러가 안나온다
interface Cylinder {
  radius: number;
  height: number;
}

const Cylinder = (radius: number, height:number) => (return {radius,height};)

// 하지만 아래는 에러가 일어날 수 있다.
function calculateVolume(shape: unknown) {
  if (shape instanceof Cylinder) {
    shape.radius // '{}' 형식에 'radius' 속성이 없습니다
  }
}
```

- 오류의 순서
  1. `instanceof` 를 통해 shape가 Cylinder 타입인지 체크
  2. `instanceof`는 자바스크립트의 런타임 연산자
  3. 즉, 값에 대해서 연산을 한다
  4. `interface`를 체크하는게 아니라 **_함수 Cylinder_**를 참고한다!

위 상황에 대한 개념이 잘 안잡힌다면 [타입스크립트 플레이그라운드](https://www.typescriptlang.org/play)를 활용해야한다. 해당 페이지에서 자바스크립트로 변환한 모습을 확인할 수가 있다.

그래서 만약에 원천적으로 피하고 싶다면 우리는 `class`와 `enum`을 이용할 수는 있다. 둘은 상황에 따라 타입과 값 두 가지 모두 가능한 예약어이다.

비슷하게 `typeof`는 타입에서 쓰일 때와 값에서 쓰일 떄 다른 기능을 한다.

```typescript
interface Person {
  first: string;
  last: string;
}
const p: Person = { first: "Jane", last: "Jacobs" };
function email(p: Person, subject: string, body: string): Response {}

type T1 = typeof p; // 타입은 Person
type T2 = typeof email; // 타입은 (p:Person, subject:string, body: string) => Response
const v1 = typeof p; // 값은 'object'
const v2 = typeof email; // 값은 'function'

const v = typeof Culinder; // 값이 'function'
type T = typeof Cylinder; // 타입이 typeof Cylinder

declare let fn: T;
const c = new fn(); // 타입이 Cylinder
// 아래 코드는 위 두줄과 똑같은 코드다
type c = IntanceType<typeof Culinder>; // 타입이 Cylinder
```

- typeof

  - 타입의 관점
    - `typeof`는 값을 읽어서 타입스크립트 타입을 반환
  - 값의 관점
    - `typeof`는 자바스크립트 런타임의 `typeof`연산자가 된다
    - 대상 심벌의 런타임 타입을 가리키는 문자열을 반환
    - 타입스크립트의 타입과는 다르다.
      - 자바스크립트의 타입을 말해줌

- 요약
  - 타입스크립트 코드를 읽을 때 타입인지 값인지 구분하는 방법을 터득해야한다.
  - 모든 값은 타입을 가진다. 하지만 타입은 값을 가지지 않는다
  - class, enum은 타임과 값 두가지로 사용가능
  - 'foo'는 문자열 리터럴이거나 문자열 리터럴 타입일 수 있다. 구분할 수 있고 구분해서 사용할 줄 알아야한다.
  - typeof, this는 사용될 때 어디공간인지 파악하고 이용해야 한다
