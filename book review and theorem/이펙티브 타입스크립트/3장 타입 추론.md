# 3장 타입 추론

> 타입스크립트는 타입 추론을 적극적으로 수행합니다. 타입 추론은 수동으로 명시해야 하는 타입 구문의 수를 엄청나게 줄여 주기 때문에, 코드의 전체적인 안정성이 향상됩니다.
>
> 숙련자와 비숙련자의 구분은 타입 구문을 적절하게 이용한다는 것이다. 도배하지 않고.
>
> 그러한 길로 갈 수 있는 방안들을 살펴보도록 하자

## 아이템 19 추론 가능한 타입을 사용해 장황한 코드 방지하기

일단 굳이 아래와 같이 짜는 것은 기본적으로 피하자! (지금의 나잖아! ~~ㅅㅂ~~)

```typescript
let x: number = 12;
```

`let x = 12`로 이미 충분하게 타입부터 알 수 있다!! 더 복잡한 객체도 추론 가능한데 굳이 아래와 같이 하지말고 생략해서 쓸 수도 있다!

```typescript
const person: {
  name: string;
  born: {
    where: string;
    when: string;
  };
  died: { where: string; when: string };
} = {
  name: "Sojourner Truth",
  born: { where: "Swartekill, NY", when: "c.1797" },
  died: { where: "Battle Creek, MI", when: "Nov. 26, 1883" },
};

/// 아래와 같이 써도 충분이 추론이 된다.
const person = {
  name: "Sojourner Truth",
  born: { where: "Swartekill, NY", when: "c.1797" },
  died: { where: "Battle Creek, MI", when: "Nov. 26, 1883" },
};
```

함수의 리턴값으로 나오는 경우도 제대로 정확하게 추론가능하다! 그리고 이러한 타입추론은 함수의 에러를 추적하는데에도 큰 도움이 된다! 그리고 destructuring에서도 타입 선언은 가능은 한데 번잡해진다. 피할 수 있으면 피하도록 하자. 어차피 타입 추론은 가능하다.

매개 변수가 있는 경우에도 타입추론은 자동으로 한다

```typescript
function parseNumber(str: string, base = 10) {
  // base의 타입은 number로 잘 찍힌다
}

// 이것은 좀 피하자 (현재의 나잖아)
app.get("/health", (request: express.Request, response: express.Response) => {
  response.send("OK");
});

// 이렇게 쓰자
app.get("/health", (request, response) => {
  response.send("OK");
});
```

함수 반환 타입도 명시를 하면 오류 방지가 가능하다. 주식 시세를 조회하고 조회한 종목에 대해서 캐시를 만들어두는 함수를 만들어보자.

```typescript
const cache: { [ticker: string]: number } = {};
const getQuote = (ticker: string) => {
  if (ticker in cache) {
    return cache[ticker];
  }
  return fetch(`https://quotes.example.com/?q=${ticker}`)
    .then((response) => response.json())
    .then((quote) => {
      cache[ticker] = quote;
      return quote;
    });
};
```

하지만 사실 위 함수는 문제가 있다. `ticker`가 있는 경우에는 `number`를 반환하지만 없는 경우에는 `Promise`객체를 반환하게 된다! 우리는 리턴값에 제대로된 타입을 명시해주는 것이 좋을 가능성이 높다!

- 요약
  - 타입스크립트가 타입을 추론할 수 있다면 타입 구문을 작성하지 않는 게 좋다
  - 이상적인 경우 함수/메서드의 시그니처에는 타입 구문이 있지만, 함수 내의 지역 변수에는 타입 구문이 없습니다.
  - 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야합니다. 이는 내부 구현의 오류가 사용자 코드 위치에 나타나는 것을 방지해 줍니다.
