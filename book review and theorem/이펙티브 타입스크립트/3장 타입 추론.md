# 3장 타입 추론

> 타입스크립트는 타입 추론을 적극적으로 수행합니다. 타입 추론은 수동으로 명시해야 하는 타입 구문의 수를 엄청나게 줄여 주기 때문에, 코드의 전체적인 안정성이 향상됩니다.
>
> 숙련자와 비숙련자의 구분은 타입 구문을 적절하게 이용한다는 것이다. 도배하지 않고.
>
> 그러한 길로 갈 수 있는 방안들을 살펴보도록 하자

## 아이템 19 추론 가능한 타입을 사용해 장황한 코드 방지하기

일단 굳이 아래와 같이 짜는 것은 기본적으로 피하자! (지금의 나잖아! ~~ㅅㅂ~~)

```typescript
let x: number = 12;
```

`let x = 12`로 이미 충분하게 타입부터 알 수 있다!! 더 복잡한 객체도 추론 가능한데 굳이 아래와 같이 하지말고 생략해서 쓸 수도 있다!

```typescript
const person: {
  name: string;
  born: {
    where: string;
    when: string;
  };
  died: { where: string; when: string };
} = {
  name: "Sojourner Truth",
  born: { where: "Swartekill, NY", when: "c.1797" },
  died: { where: "Battle Creek, MI", when: "Nov. 26, 1883" },
};

/// 아래와 같이 써도 충분이 추론이 된다.
const person = {
  name: "Sojourner Truth",
  born: { where: "Swartekill, NY", when: "c.1797" },
  died: { where: "Battle Creek, MI", when: "Nov. 26, 1883" },
};
```

함수의 리턴값으로 나오는 경우도 제대로 정확하게 추론가능하다! 그리고 이러한 타입추론은 함수의 에러를 추적하는데에도 큰 도움이 된다! 그리고 destructuring에서도 타입 선언은 가능은 한데 번잡해진다. 피할 수 있으면 피하도록 하자. 어차피 타입 추론은 가능하다.

매개 변수가 있는 경우에도 타입추론은 자동으로 한다

```typescript
function parseNumber(str: string, base = 10) {
  // base의 타입은 number로 잘 찍힌다
}

// 이것은 좀 피하자 (현재의 나잖아)
app.get("/health", (request: express.Request, response: express.Response) => {
  response.send("OK");
});

// 이렇게 쓰자
app.get("/health", (request, response) => {
  response.send("OK");
});
```

함수 반환 타입도 명시를 하면 오류 방지가 가능하다. 주식 시세를 조회하고 조회한 종목에 대해서 캐시를 만들어두는 함수를 만들어보자.

```typescript
const cache: { [ticker: string]: number } = {};
const getQuote = (ticker: string) => {
  if (ticker in cache) {
    return cache[ticker];
  }
  return fetch(`https://quotes.example.com/?q=${ticker}`)
    .then((response) => response.json())
    .then((quote) => {
      cache[ticker] = quote;
      return quote;
    });
};
```

하지만 사실 위 함수는 문제가 있다. `ticker`가 있는 경우에는 `number`를 반환하지만 없는 경우에는 `Promise`객체를 반환하게 된다! 우리는 리턴값에 제대로된 타입을 명시해주는 것이 좋을 가능성이 높다!

- 요약
  - 타입스크립트가 타입을 추론할 수 있다면 타입 구문을 작성하지 않는 게 좋다
  - 이상적인 경우 함수/메서드의 시그니처에는 타입 구문이 있지만, 함수 내의 지역 변수에는 타입 구문이 없습니다.
  - 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야합니다. 이는 내부 구현의 오류가 사용자 코드 위치에 나타나는 것을 방지해 줍니다.

## 아이템 20 다른 타입에는 다른 변수 사용하기

```javascript
// js에서는 아래 코드가 되지만 ts에서는 안된다
let id = "12-34-56";
fetchProduct(id);
id = 123456;
fetchProductBySerialNumber(id);
```

만약 정말로 위 코드처럼 ts에서도 동작하게 하고 싶다면 아래와 같이 하는 방법은 있긴 하다.

```typescript
let id: string | number = "12-34-56";
fetchProduct(id);
id = 123456;
fetchProductBySerialNumber(id);

// 당연하게도 위 컨셉은 권장하진 않고 차라리 아래 방식대로 새 변수를 만드는 것이 좋아보인다
const id = "12-34-56";
fetchProduct(id);
const serial = 123456;
fetchProductBySerialNumber(serial);

// 아니면 아래도 가능하다
const id = "12-34-56";
fetchProduct(id);
{
  const id = 123456;
  fetchProductBySerialNumber(id);
}
```

아래 상황을 기억하고 따로 변수를 지정하자

- 서로 관련이 없는 두 개의 값을 분리하자
- 변수명을 더 구체적으로 지을 수 있습니다
- 타입추론을 향상시키며, 타입 구문이 불필요해진다
- 타입이 좀 더 간결해진다
- let 대신 const로 변수를 선언하게 된다

- 요약
  - 변수의 값은 바뀔 수 있지만 타입은 일반적으로 바뀌지 않습니다.
  - 혼란을 막기 위해 타입이 다른 값을 다룰 때에는 변수를 재사용하지 않도록 합니다.

## 아이템 21 타입 넓히기

벡터를 다루는 라이브러리를 작성한다고 가정해보자. 아래와 같은 코드가 있을 것이다

```typescript
interface Vector3 {
  x: number;
  y: number;
  z: number;
}
function getComponent(vector: Vector3, axis: "x" | "y" | "z") {
  return vector[axis];
}
```

언뜻보면 자연스럽게 동작해야할 거 같은데 `'string'형식의 인수는 "'x'|'y'|'z'"형식의 매개변수에 할당될 수 없습니다` 에러를 발견할 수 있다.

타입스크립트의 타입추론은 영리하다. 사람의 의도도 알려고 한다. 하지만 사람 마음 속은 한길도 알 수 없다고 항상 옳을 수는 없다. `타입 넓히기`과정에서 제어를 해야하는 경우도 많다. 그 중 한 방법은 `const`를 이용하는 것이다.

```typescript
const x = "x"; // 타입이 'x'
let vec = { x: 10, y: 20, z: 30 };
getComponent(vec, x); // 정상
```

허나 `const`도 만능은 아니다. 객체와 배열의 경우에는 여전히 문제가 있다 `const mixed = [1,'2']`의 경우에는 `(string|number)[]`로 추측하지만 항상 이게 옳은 것은 아닐 것이다. 그리고 비슷한 경우는 객체에서도 발생한다.

```typescript
const v = { x: 1 };
v.x = 3;
v.x = "3";
v.y = 4;
v.name = "Pythagoras";
```

타입 추론이 상황별로 다양하게 날 것이다. 가장 구체적인 케이스는 `{readonly x:1}` 가장 추상적인 케이스는 `{[key: string]: number}`로 추측할 것이다.

- 기본 동작을 재정의 하는 세가지 방법을 알아보자

  1. 명시적 타입 구문을 제공하는 것
     - ```typescript
       const v: { x: 1 | 3 | 5 } = { x: 1 }; // 타입이 {x:1|3|5}
       ```
  2. 타입 체커에 추가적인 문맥을 제공하는 것
     - 예를 들어, 함수의 매개변수로 값을 전달.
     - 아이템 26에서 좀 더 명확히 다뤄보자
  3. const 단언문을 사용하는 것
     - ```typescript
       const v1 = {
         x: 1,
         y: 2,
       }; // 타입은 {x:number, y:number}
       const v2 = {
         x: 1 as const,
         y: 2,
       }; // 타입은  {x: 1, t: number}
       const v3 = {
         x: 1,
         y: 2,
       } as const; // 타입은 {readonly x: 1; readonly y: 2}
       ```
     - 값 뒤에 `as const`를 작성하면, 타입스크립트는 최대한 좁은 타입으로 추론한다.

- 요약
  - 타입스크립트가 넓히기를 통해 상수의 타입을 추론하는 법ㅇ르 이해해야 합니다
  - 동작에 영향을 줄 수 있는 방법인 const, 타입 구문, 문맥, as const에 익숙해져야 합니다
