# 1장 웹 개발과 GraphQL

## 1.1 웹 개발의 간략한 역사

- 팀 버너스 리가 1990년대 www를 시작으로 인터넷의 시대가 본격적으로 시작
- 초기 웹은 `HTML`과 `CSS`만으로 이루어진 단순한 텍스트 정보 나열이었다
- HTML문서와 각 태그들, DOM기술이 점차적으로 발전 => JS가 웹 페이지를 조절할 수 있는 기능이 더욱 ㅁ낳아짐
- JS가 지속적으로 발전
- AJAX 발전
- AJAX의 발전으로 프론트엔드와 백엔드의 분리가 촉진
- 프론트는 SPA를 구현할 수 있는 도구들이 발전
- 백엔드는 프론트와 효율적 통신을 고민
  - SOAP
    - 첫 등장
    - 조금 엄격하고 복잡한 표준
    - 대역폭이 많이 필요한 문제 보유
  - REST
    - HTTP 상에서의 리소스 기반으로 통신 규칙을 정의
    - SOAP에 비해 복잡하지 않고 다양한 파일 포맷을 다룰 수 있음
    - RESTful API라는 용어까지 등장
  - GraphQL
    - 데이터 중심
    - REST의 몇 문제를 해결

## 1.2 GraphQL

- 페이스북으로부터 시작
- GraphQL은 클라이언트 애플리케이션을 위한 쿼리 언어
- 직관적이고 유연한 구문을 통해 데이터를 설명하고 데이터 간의 상호작용을 설명할 수 있도록 설계되어 있다
- ID가 13인 필름의 제목을 요청하는 쿼리
  ```GraphQL
  query {
      Film(id: 13) {
          title
      }
  }
  ```
- 위 요청은 아래와 같은 JSON을 반환해야한다
  ```JSON
  {
      "Film": {
          "title": "붉은 돼지"
      }
  }
  ```

### GraphQL?

- 쿼리언어입니다
  - SQL은 RDBMS의 데이터를 검색 및 관리하기 위한 언어
- GraphQL은 클라이언트가 API 서버로부터 데이터를 검색하거나 관리하기 위한 언어
  - 기능적으로는 SQL과 동일
  - 사용되는 환경과 사용 형태가 다르다
  - GraphQL을 다루는 서버는 웹 프런트엔드, 모바일 프런트엔드 등의 화면을 구성하는 다양한 클라이언트로부터 쿼리를 전송받습니다
  - 쿼리를 전송받은 GraphQL 서버는 쿼리에서 명시된 데이터에 접근하여 데이터를 요청 받은 형태로 반환
- 리졸버가 쿼리를 잘 해결해주는 겁니다
  - GraphQL 서버에서는 각 데이터에 대한 리졸브 함수를 작성하여 데이터에 접근
  - 리졸버는 특정 데이터 필드를 조작하는 함수

### GraphQL의 설계 디자인 원칙

1. 계층적
   - GraphQL 쿼리와 반환되는 데이터 형태 역시 계층적 구조를 지님으로써 더욱 일관성 있고 자연스러운 개발을 가능케 합니다
   - 오늘날 대표적인 계층 구조의 데이터 형태인 JSON과 그 형태가 매우 유사
2. 제품 중심
   - ㅋ르라이언트를 개발하는 프런트엔드 엔지니어의 요구사항에 의해 주도적으로 작성됩니다
3. 강력한 타입 제한
   - GraphQL은 타입 시스템을 통해 데이터와 데이터의 관계를 정의하고 유효성 검사를 진행
4. 클라이언트 맞춤 쿼리
   - GraphQL의 활용으로 인해 클라이언트가 데이터에 대한 우선적인 선택권을 지니게 됩니다.
   - 기존에는 서버에서 응답된 데이터에 맞추어 클라이언트를 개발해 나가야 했다면, GraphQL의 적용으로 클라이언트가 요청한 데이터만을 서버에서 응답하게 됩니다
5. 인트로스펙티브
   - GraphQL은 현재 정의된 자신의 타입 정보와 명세 등의 정보를 쿼리할 수 있어, 클라이언트 측 라이브러리 또는 도구와 같은 플랫폼 구축을 가능하게 합니다

### REST

> ~~REST는 신이다~~
>
> REST는 몇 가지의 제약을 제안하여 HTTP를 올바르게 활용할 수 있도록 하였습니다

1. 클라이언트 - 서버 구조
   - 클라이언트와 서버 구조를 따르라는 제약.
   - 각 구성요소는 독립적으로 발전하며 서로 합의된 인터페이스를 통해 소통합니다
2. 무상태
   - 서버는 상태를 가지면 안 된다는 제약입니다
   - 이로써 서버는 들어오는 요청만을 처리하면 되고
   - 구현이 단순해지는 효과가 나타난다
   - 확장성에 더욱 유리
3. 캐시 가능
   - HTTP의 주요 기능 중 하나인 캐시 기능을 적극적으로 활용할 수 있어야 한다는 제약입니다
4. 인터페이스 일관성
   - 클라이언트, 서버 등은 일관된 인터페이스를 가져야 한다는 제약입니다

제약은 이것 이외에도 더 있지만 대표적인것만 모아봤다

### REST의 문제점과 GraphQL

1. REST는 리소스 중심이므로, 복잡성이 불가피합니다
2. REST는 오버 페칭의 문제를 가지고 있습니다
   - 필요 없는 정보까지 줄 수 있습니다
3. REST는 언더 페칭의 문제를 가지고 있습니다
   - 필요 있는 정보를 안 줄 수도 있습니다

### GraphQL과 REST의 차이

| 비교점                                | REST                                                      | GraphQL                                                                        |
| ------------------------------------- | --------------------------------------------------------- | ------------------------------------------------------------------------------ |
| 데이터의 형태 정의와 데이터 요청 방법 | 연결되어 있다                                             | 완번히 분리되어 있다                                                           |
| 데이터의 크기와 형태                  | 서버에서 결정                                             | 데이터에 대한 정보만 정의하고 필요한 크기와 형태는 클라이언트에서 요청 시 결정 |
| 데이터 표현                           | URI가 데이터를 나타냄, HTTP 메서드가 작업의 유형을 나타냄 | 스키마가 데이터를 나타냄, 쿼리 or 뮤테이션 타입이 작업의 유형을 나타냄         |
| 여러 데이터                           | 여러번 요청이 필요                                        | 한번의 요청으로 처리 가능                                                      |
| 작업 처리                             | 엔드포인트에 정의된 핸들링 함수를 호출하여 작업을 처리    | 요청받은 각 필드에 대한 리졸버 함수를 연쇄적으로 호출하여 작업을 처리          |

### GraphQL이 가져오는 부가적 이점

- 개발자 간의 의사소통 문제를 해결하기도 한다
- 클라이언트 - 서버 구조가 정착된 이후부터 프런트엔드와 백엔드로 나뉜 개발 분야는 팀으로 분할되었다.
- 전문성은 있지만 소통과 업무에 대한 부담이 적지 않아 있다
- GraphQL은 프런트와 백의 독립성을 유지하면서도 그 중간에서 동일한 데이터 모델과 동일한 비즈니스 로직을 공유할 수 있도록 합니다.

## 1.3 GraphQL 사용하기

> 웹 서비스를 포함한 대부분의 소프트웨어는 기본적으로, 데이터를 생성하고 조회하고 수정하고 삭제하는 작업을 처리하는 과정으로 이루어져 있습니다.
>
> 대부분 이 네가지 과정을 CRUD라고 부릅니다
>
> 이 장은 그냥 예시만 보여주고 있어서 따로 정리하기 애매하니 직접 읽어보는게 나을 수도?
