# 3. 함수

> 1. 작게 만들어라
> 2. 한 가지만 해라
> 3. 함수 당 추상화 수준은 하나로
> 4. switch 문
> 5. 서술적인 이름을 사용하라
> 6. 함수 인수
> 7. 부수 효과를 일으키지 마라
> 8. 명령과 조회를 분리하라
> 9. 오류 코드보다 예외를 사용하라
> 10. 반복하지 마라
> 11. 구조적 프로그래밍
> 12. 함수를 어떻게 짜죠?
> 13. 결론

프로그래밍 초창기에는 시스템을 루틴과 하위 루틴으로 나눴다. 포트란과 PL/1시절에는 프로그램, 하위 프로그램, 함수로 나눴다. 하지만 지금은 함수만 살아남았다. 이 장에서는 함수를 잘 만드는 법을 소개한다.

## 1. 작게 만들어라

함수를 만드는 첫째 규칙은 '작게!'다. 둘째 규칙은 '더 작게!'이다. 얼마나 짧아야 좋을까? 짧을 수록 좋다! 그리고 작게 쪼개야하는 것이 매우 중요하다.

중첩 구조가 생길만ㅋ큼 함수가 커져서는 안된다. 그럼므로 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다. 당연한 말이지만 그래야 함수는 읽고 이해하기 쉬워진다.

## 2. 한 가지만 해라

> 함수는 한 가지를 해야 한다. 그 한가지를 **잘** 해야 한다. 그 한 가지만을 해야 한다.

이 충고를 기억해야만 한다. 

## 3. 함수 당 추상화 수준은 하나로

함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다. 함수 내에 다른 추상화 수준들이 다 섞여 있으면 이해하기가 어렵다. 한 함수내에 높은 수준의 추상화인 `getHtml()`같은 함수와 중간정도인 어떤 메서드 그리고 낮은 수준인 `append()` 이것들을 다같이 이용하고 있으면 코드를 이해하는데에 매우 큰 어려움이 있다.

- 위에서 아래로 코드 읽기: 내려가기 규칙

  코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 일련의 TO 문단을 읽듯이 프로그램이 읽혀야 한다는 의미다. 여기서 각 TO 문단은 현재 추상화 수준을 설명하며 이어지는 TO 문단을 참고 해야한다.

추상화 수준이 하나인 함수를 유지하기는 힘들 수가 있다. 하지만 해야만 한다.

## 4. switch 문

switch 문은 작게 만들기 어렵다. 아래 코드를 한번 보자

```java
public Money caclulaatePay(Employee e)
    throws InvalidEmployeeType {
    switch (e.type) {
        case COMMISIONED:
            return calcuateCommissionedPay(e);
        case HOURLY:
            return calculateHourlyPay(e);
        case SALARIED:
            return calculateSalariedPay(e);
        default:
            throw new InvalidEmployeeType(e.type);
    }
}
```

위 함수에는 몇가지 문제가 있다.

1. 함수가 길다. 직원 유형이 추가되면 계속해서 추가될 것이다
2. '한 가지' 작업만 수행하지 않는다
3. SRP를 위반한다. Single Responsibility Principle
4. OCP을 위반한다. Open Closed Principle

위 상황들을 피하기 위한 조건은 `추상 팩토리에 switch문을 숨겨라`이다. 아무에게도 보여주지 않고 팩토리는 switch문을 사용해 적절한 파생 클래스의 인스턴스를 생성한다면 깔끔하게 보일 것이다

## 5. 서술적인 이름을 사용하라

단 하나의 룰 `코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다` 이것을 기억하자. 시간제한있는 문제를 푸는 것이 아니라면 이름을 정하느라 시간을 들여도 괜찮다. 길고 서술적인 이름이 좋다. 최신 IDE에서 이름바꾸는 것은 식은 죽 먹기임으로 괜찮아 보이는 이름을 넣고 그 이후에 다시 수정해도 괜찮다

## 6. 함수 인수

이상적인 갯수는 0개. 많아도 2개까지만 하자. 정말 필요한 경우에 3개까지 하지만 왠만하면 피하자. 왜냐하면 일단 테스트에서 너무 부담감이 커진다.

- 많이 쓰는 단항 형식

  함수에 인수 1개를 넘기는 이유중 가장 흔한 경우는 두가지다.

  1. 인수에 질문을 던지는 경우

     `boolean fileExists("MyFile")`같은 케이스이다.

  2. 인수를 뭔가로 변환해 결과를 반환하는 경우

     `InputStream fileOpen("MyFile")`은 String 형의 파일 이름을 InputStream으로 반환한다.

  이런 식의 케이스들은 독자가 당연하게 받아들인다. 가끔 쓰이는 경우는 단항 함수 형식 이벤트이다. `passwordAttemptFailedNtimes(int attemps)`같은 예가 있다. 이런 경우에 이것이 이벤트라는 것을 명확하게 보여줘야 한다. 그러니 이런 경우에는 이름과 문잭을 주의해서 선택하라

  진짜 위 2가지(마지막 케이스까지 3개)말고는 단항 함수를 피하자. 특히, void같은 경우 혼란을 많이 야기한다.

- 플래그 인수

  좀 추한 케이스이다 ~~추래그 플하다~~. 특히, 부울 값! 끔찍한 케이스다. 왜냐하면 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈이다.

- 이항 함수

  인수가 2개인 함수는 자연히 인수가 1개인 함수보다 이해하기 어렵다. 물론 적절한 케이스도 당연히 존재는 한다. 좌표값을 인수로 받는다던가 둘을 비교하는 케이스들 말이다. 무조건 나쁘다는 소리가 아니다 불가피한 케이스도 당연히 생기기 마련이다.

  하지만 언제나 인지하자. 위험이 따르고 가독성을 저하시킨다는 것을 말이다.

- 삼항 함수

  인수가 3개면 당연히 더 어려워진다. 진짜 신중히 권고해라. 두개보다 매우 가독성을 떨어뜨리기 때문에 2개도 많은 고민을 해야하지만 3개는 더욱더 고민해야한다.

- 인수 객체

  인수가 2-3개 필요하다면 독자적인 클래스 변수로 선언할 간으성을 짚어본다. 밑 코드에서 두 함수를 비교해부자

  ```java
  Circle MakeCircle(double x, double y, double radius);
  Circle MakeCircle(Point center, double radius);
  ```

  눈속임이라고 여길 수도 있다. 하지만 위와같이 직관적이게 할 수 있는 케이스면 좋은 선택이다!

- 인수 목록

  인수 개수가 가변적인 함수도 필요할 것이다. 대표적인 예가 `String.format`일 것이다. 하지만 이러한 것들은 2항, 3항 함수처럼 보이게 할 수가 있다.

  ```java
  void monad(Integer... args);
  void dyad(String name, Integer... args);
  void triad(String name, int count, Integer... args);
  ```

  이런식으로 인수가 적게 보일 수도 있고 생각보다 많이 직관적이다.

- 동사와 키워드

  함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수이고 인수와 함께 ***동사/명사*** 쌍을 이뤄야 한다

## 7. 부수 효과를 일으키지 마라

부수 효과. 허물좋은 헛소리이다. 거짓말일 뿐이다. 예상치 못하게 클래스 변수 수정까지 할 수가 있다. 이런 경우 코드에 대한 오독이 더 올라갈 수가 있다. 밑의 코들르 보자. 무해하게 보이지만 많은 부수효과를 일으킨다

``` java
public class UserVaalidator {
    private Cryptographer cryptographer;
    
    public boolean checkPassword(String userName, String password) {
        User user = UserGateway.findByName(userName);
        if (user != User.NULL) {
            String codedPhrase = user.getPhraseEncodedByPssword();
            String phrase = cryptographer.decrypt(codedPhrase, password);
            if ("Valid Password".equals(phrase)) {
                Session.initialize();
                return true;
            }
        }
        return false;
    }
}
```

부수효과가 보이는가? `Session.initialize()`를 호출하는 것이다. checkPassword는 말 그래도 체크만 할 뿐인데 저것을 호출하는 것은 언어 도단이며 문제가 생길 수가 있다. 그리고 세션을 초기화하는 부수효과를 왜 일으키는지 가독성을 저해할 수가 있다. 함수이름이 적절치 않게 되었다면 오히려 세션초기화용 함수로 착각할 수가 있다.

이러한 경우 Session.initialize를 제거하던가 함수를 `checkPasswordAndSessionInitialize`로 바꾸는 것이 옳다

## 8. 명령과 조회를 분리하라

함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야한다. 둘 다 하면 안된다. 객체 상태를 변경하거나 객체 정보를 반환하거나 둘 중 하나이다. 아래와 같은 함수가 있다고 생각해보자

```java
public boolean set(String attribute, String value)
```

위 함수는 attribute인 속성을 찾아서 값을 value로 바꾸고 성공하면 true 실패하면 false를 반환한다고 해보자 그리고 사용을 해보자

```java
if (set("username","unclebob"))...
```

위 코드를 작성했을 때 누군가가 위 코드를 보면 생각을 할 것이다. `username이랑 unclebob이 같은지를 보는건가? 이름을 보면 바꾸는거 같은데? 뭐지?` 혼란 야기가 맴우 쉽다. 함수 이름을 제대로 하는 것도 중요하지만 한가지 역할만을 하는 것도 중요하다!

## 9. 오류 코드보다 예외를 사용하라

명령 함수에서 오류 코드를 반호나하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.

오류 처리도 한가지 작업이기 때문에 함수내에서 존재한다면 좋지 않다고 할 수가 있다.

## 10. 반복하지 마라

중복이 되는 코드는 함수로 다시 처리할 수가 있을 것이다. 그리고 같은 로직이라고 하면 로직을 수정할 시에 전부 수정해야되는 문제가 발생하니 묶어두는 것이 좋다

## 11. 구조적 프로그래밍

테이크스트라는 모든 함수와 함수 내 모든 블록에 입구와 출구가 하남만 존재해야 한다고 말했다. 즉, 함수는 return 문이 하나여야 한다는 말이다. 루프 안에서 break나 countinue를 사용해선 안되며 goto는 절대로 절대로 사용해서는 안된다.

하지만 역으로 작게 만든다면 여러번 사용해도 괜찮다. 하지만 goto는 진짜 진짜 기피하도록 하자

## 12. 함수를 어떻게 짜죠?

글짓기와 비슷하다. 먼저 생각을 기록한 후 읽기 좋게 다듬는다.

## 13. 결론

길이가 짧고, 이름이 좋고, 체계가 잡힌 함수를 만들도록 노력하자.