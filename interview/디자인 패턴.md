# 디자인 패턴

> 객체지향 프로그래밍에서 공통적인 디자인 문제를 찾아내고 해결하는 가이드라인을 디자인 패턴이라고 부른다.

디자인 패턴은 프레임 워크나 클래스 라이브러리와 달리 추상적인 것으로, 실제 코드를 제공하는 건 아니고 특정 유형의 프로그래밍 문제를 해결하는 방식을 제공해 주는 역할을 한다.

디자인 패턴은 **Design Patterns: Elements of Reusable Object Oriented Software**라는 책이 나오면서부터 널리 알려지고 제 모습을 갖추게 되었으나, 개념 자체는 그 책이 나오기 전부터 있었다. 반복자나 싱글턴 같은 몇몇 핵심적인 디자인 패턴은 대부분의 자바나 C++ 프로그래머들에게 널리 알려져 있다. 빌더 패턴같이 인지도는 좀 낮지만 상황에 따라 매우 유용하게 쓰이는 것도 있다.

## 디자인 패턴을 쓰는 이유

1. 여러 프로그래머들의 경험과 지혜를 모아서 공통적인 소프트웨어 디자인 문제를 해결하는 데 도움이 될 수 있게 만들어 놓은 것이기 때문이다.
2. 디자인 문제와 그 해결책을 논할 때 디자인 패턴이 간결한 용어모음을 제공한다는 점이다.

## 일반적인 디자인 패턴

- 싱글톤

  싱글톤 패턴은 어떤 클래스의 인스턴스 개수가 최대 한 개를 넘지 않도록 하는 패턴이다. 이 인스턴스는 공유자원에 대한 문지기 또는 중앙에 있는 소통의 중심 역할을 한다. 애플리케이션에서 새 인스턴스를 만들 수 없으며, 모든 메서드는 싱글톤을 통해서만 액세스할 수 있다. 애플리케이션에서는 클래스에 있는 정적 메서드를 호출하여 싱글톤을 가져온다.

  핵심 시스템 함수는 보통 싱글톤을 통해 액세스한다. 예를 들어 자바의 `java.lang.Runtime` 클래스는 애플리케이션 실행 환경과의 소통을 위해 쓰이는 싱글톤이다. 전역 변수를 대체하기 위해 싱글톤을 쓰기도 하지만, 싱글톤 패턴을 쓴다고 해서 전역 변수의 전역 상태 문제가 해결되는 건 아니기 때문에 싱글톤을 이용하여 전역 데이터를 저장하는 것을 안티 패턴으로 보는 사람도 많다. 정적보다 나은 이유는 뭔가?

  - 상속과 인터페이스

    싱글톤은 객체다. 따라서 베이스 클래스로부터 상속을 받고 인터페이스를 구현할 수 있다.

  - 다수 객체로 전환 가능

    나중에 마음이 바뀌어 (예를 들어 스레드당 하나같은 식으로) 여러 객체를 만들고자 하는 경우에 코드를 많이 바꾸지 않고도 원한는 바를 이룰 수 있다.

  - 동적 바인딩

    싱글톤을 생성하기 위해 실제로 사용하는 클래스를 컴파일할 때가 아닌 실행할 때 결정할 수 있다.

- 빌더

  빌더 패턴은 객체가 어떤 식으로 구축되는지에 대해 모르는 상황에서 단계별로 객체를 생성하는 패턴이다. 객체를 직접 생성하는 대신 빌더의 인스턴스를 만들고 빌더에서 객체를 대신 만들도록 하는 방식이다.

  ```java
  public class Window {
      public Window( boolean visible, boolean modal, boolean dialog ){
          this.visible = visible;
          this.modal = modal;
          this.dialog = dialog;
      }
  
      private boolean visible;
      private boolean modal;
      private boolean dialog;
  
      // 이하 클래스에 필요한 내용
  }
  ```

  위 코드를 가지고 설명해보자. Window 생성자에서는 세 개의 부울 매개변수를 받아들이는데 그 순서가 헷갈릴 수 있다. 쓸 때마다 어떤 매개변수가 어떤 특성을 나타내는지 잊어버려서 일일이 클래스 문서를 뒤적거리면ㄴ서 찾기보다는 빌더를 만들어서 거기서 필요한 데이터를 모으고 객체를 생성하게 만드는 쪽이 더 낫다.

  ```java
  public class WondowBuilder {
      public WindowBuilder() {}
  
      public WindowBuilder setDialog( boolean flag ){
          dialog = flag;
          return this;
      }
  
      public WindowBuilder setModal( boolean flag ){
          modal = flag;
          return this;
      }
  
      public WindowBuilder setVisible( boolean flag ){
          visible = flag;
          return this;
      }
  
      public Window build() {
          return new Window( visible, modal, dialog );
      }
  
      private boolean dialog;
      private boolean modal;
      private boolean visible;
  }
  ```

  위와 같은 방식으로 수정할 수 있다. 이렇게 하면 한번에 값을 넣는 것이 아니라. builder을 통해서 각각에 set을 이용해 만들 수가 있다.

- 팩토리 메서드

  새 객체를 만들어서 리턴하기 위한 용도로 만들어진 모든 메서드라는 개념을 클래스 계층구조에 적용한 것이다. 베이스 클래스에서는 서브클래스에서 오버라이드할 팩토리 메서드를 정의하며, 새 객체가 생성되는 방법은 각 서브클래스에서 결정한다.

- 추상 팩토리

  다른 객체를 만들 수 있는 개체를 팩토리라고 부른다. 추상 팩토리 패턴은 팩토리의 구현과 그 팩토리를 사용하는 코드를 갈라주는 패턴이다.

  추상 팩토리는 보통 어떤 추상 클래스로부터 상속된 일련의 팩토리 클래스로 구현된다. 구현된 여러 팩토리 중에서 어떤 것을 사용할지 결정하고 나면 애플리케이션에서는 실제 (구상) 클래스가 아닌 추상 클래스를 통해서만 그 팩토리를 참조한다. 따라서 팩토리 선택은 실제 실행할 때까지 설정 파일 등을 통해 미뤄질 수도 있으며, 프로그램이 실행되는 도중에 다른 팩토리를 선택하는 것도 가능하다.

  서로 다른 팩토리를 쓸때 또는 팩토리 클래스가 하나 박에 없을 때는 사용안한다.

- 반복자

  반복자 패턴을 쓰면 어떤 자료구조에 있는ㄴ 모든 원소를 종주할 수 있으며, 이 때 각 원소가 어떤 식으로 저장되고 표현된는지에 대해서는 특별히 신경쓰지 않아도 되고 아예 몰라도 된다. 요즘 만들어진 언어는 대부분 반복자를 자체적으로 지원한다.

  반복자에도 종류가 다양하며, 각각 사용상의 장단점이 있다. 원소를 한 방향으로만 종주할 수 있고 그 바탕이 되는 자료구조는 건드릴 수 없는 간단한 반복자가 있는가 하면, 양방향으로 종주할 수 잇고 바탕이 되는 자료구조의 원소 추가/삭제도 가능한 더 복잡한 반복자도 있다

- 옵저버

  옵저버 패턴을 쓰면 그 객체의 상태에 관심을 가지고 있는 옵저버에게 자신의 상태가 바뀌었음을 널리 알릴 수 있다. 이 때 옵저버에 대한 정보는 별로 필요하지 않다. 이런 약한 결합을 출판-구독 패턴이라고도 부른다. 옵저버는 갱신 사항을 알려주기 위해 만들어 놓은 어떤 인터페이스를 써서 대상에 등록한다. `MVC`패턴도 일종의 옵저버 패턴이라고 생각할 수가 있다

- 데코레이터

  데코레이터 패턴은 한 객체를 그 객체와 같은 베이스 클래스로부터 파생되, 그리하여 원래 객체와 같은 메서드를 제공하는 다른 객체로 감싸서 객체의 행동을 바꿔주는 패턴이다. 그래서 데코레이터 패턴을 래퍼 패턴이라고 부르기도 한다.

  데코레이터 패턴을 구현할 때는 **구성요소**, **구상 구성요소**, **데코레이터**, **구상 데코레이터** 이 네가지 유형의 클래스가 필요하다. 

## 디자인 패턴 문제

### 싱글톤 구현

> 어떤 애플리케이션에서 콘솔에 디버깅 메시지를 출력하기 위한 로거 클래스를 사용한다. 싱글톤 패턴을 써서 이런 로그 기능을 구현하는 방법을 제시해보라.

싱글톤 패턴ㄴ을 쓰면 로거 클래스의 인스턴스의 수가 한 개를 넘기지 않는다. 가장 쉬운 방법은 생성자를 private으로 선언하고 클래스 안에서 인스턴스를 하나만 초기화하는 방법이다.

```java
// 싱글토을 써서 간단한 로그용 클래스를 구현함
public class Logger {

    // 싱글톤을 생성하고 저장함
    private static final Logger instance = new Logger();

    // 다른 사람은 아무도 이 클래스를 생성할 수 없도록 함
    private Logger() {

    }

    // 싱글톤 인스턴스 리턴
    public static Logger getInsstance() { return instance; }

    /*
    * 콘솔에 문자열 로그 출력
    * 예: Logger.getInstance().log("thi i a test");
    */
    public void log( String msg ){
        System.out.println( System.currentTimeMillis() + ": " + msg );
    }
}
```

위에서 만족할 수도 있지만 더 좋은 전문가를 원한다면 아래와 같은 추가 질문이 들어올 것이다

> 애플리케이션에서 싱글톤을 쓰는데, 꼭  그게 필요한 것도 아니고 초기화 비용이 너뭄 많이 든다. 이런 상황을 개선할 수 있는 방법은?

`getInstance`에서 초기화를 하고 리턴하는 방식도 가능하다 이를 게으른 초기화 또는 게으른 로딩이라고 부른다. 다음과 같은 특징을 가진다.

- 지연 초기화를 적용하면 구독 시간ㅇ니 빨라지지만, 대신 인스턴스를 처음 액세스할 때 초기화하는 데 시간이 걸린다.
- 지연 초기화 싱글톤을 한 번ㄴ도 액세스하지 않으면 아예 초기화가 되지 않기 때문에 클래스를 불러올 때 무조건 초기화를 했더라면 필요했을 초기화에 필요한 시간과 자원ㅇ늘 절약할 수 있다.
- 지연 초기화를 이용하면 싱글톤 객체의 클래스를 컴파일할 때 지정하지 않ㄴ아도 되고, 실행할 때까지 클래스 선택을 미룰 수 있다. 인스턴스가 단 한 번만 생성되기 때문에 인스턴스를 처음 액세스하기 전에 클래스를 선택해야 하긴 하지만, 실행시에 클래스를 선택함으로써 얻을 수 있는 장점은 여전히 있다. 예를 들어, 설정 파일에 있는 내용을 바탕으로 클래스를 선택할 수도 있다.
- 자원이 제한된 환경에서는 자원이 부족해서 뒤늦게 인스턴스를 초기화할 때 문제가 생길 수 있다. 이런 특성은 필요할 때 반드시 만들어져 있어야만 하는 에러 로그용 클래스의 경우에는 특히 문제가 될 수 있다.
- 지연 초기화를 쓰면 싱글톤 클래스가 더 복잡해진다. 특히 멀티 스레드 시스템에서는 더 복잡해진다.

그러면 아래와 같이 구현이 될 것이다

```java
// 지연 초기화 버전 로거
public class Logger {

    // 싱글톤을 생성하여 저장
    private static Logger instance = null; // final 키워드는 빠짐

    // 다른 사람은 아무도 이 클래스를 생성할 수 없도록 함
    private Logger(){

    }

    // 싱글톤 인스턴스 리턴
    public static Logger getInstance() {
        if (instance == null) {
            instance = new Logger();
        }

        return instance;
    }

    // 콘솔에 문자열 로그 출력
    public void log( String msg ){
        System.out.println( System.currentTimeMillis() + ": " + msg );
    }
}
```

이것도 나쁘지 않아 보이지만 문제점은 좀 있다. 스레드 안전성 문제다. 두 스레드에서 getInstance를 동시에 호출하면 어떻게 될까? 둘 다 instance가 아직 초기화되지 않은 것으로 생각하고 각각 인스턴스를 만들려고 할 것이다. 즉 싱글톤에서는 일어나면 안되는 일이 일어난다! 동기화로 그것을 해결하자

```java
// 싱글톤 인스턴스 리턴
public synchronized static Logger getInstance() {
    if (instance == null) {
        instance = new Logger();
    }

    return instance;
}
```

### 데코레이터 vs 상속

> 상속 대신 데코레이터 패턴을 써야 하는 이유는 무엇인가?

데코레이터 패턴은 한 객체를 다른 객체로 감싸서 원래 객체의 행동을 바꾼다는 것을 기억해보자. 레퍼 객체는 원래 객체와 똑같은 추상 베이스 클래스를 공유하기 때문에 원래 객체 대신 사용할 수 있다.

### 효율적인 옵저버 업데이트

> 옵저버 패턴에서 옵저버를 효율적으로 업데이트하기 위해 어떤 전략을 취해야 할까?

옵저버 패턴을 대충 구현하면 여러 객체가 옵저버로 들어가 있을 때 성능이 확 떨어질 수 있다.

흔한 문제는 상태가 너무 자주 바뀔 때 옵저버들을 업데이트하느라 시간을 한참 쓰는 일이다. 아이디어는 바꿀 필요가 있는 것만 바꾸는 것이다.

다른 문제는 옵저버 입장에서 뭐가 바뀌었는지 알아내는 방법과 관련된 부분이다.