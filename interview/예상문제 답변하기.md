# 예상문제 답변하기

## 1. Context Switching와 Race Condition?

- Context Switching
  - cpu에서 process를 switching할때 발생하는 과정을 의미한다. 간단하게는 현재 상태의 Task를 저장하고 멈춘 후에 다음 Task의 값을 불러오는 것이다. 이때 오버헤드가 발생하긴 한다.
- Race Condition
  - 같은 데이터에 동시 접근이 가능하게 되어 결과 값이 특정 순서에 따라 달라질 수 있게되는 환경

## 2. 프로세스와 스레드의 차이점

- 프로세스
  - 프로세스는 os로부터 프로그램 실행시 메모리 영역을 할당받아 실행시키게 됩니다
- 스레드
  - 스레드는 프로세스가 프로그램을 실행시키면서 필요시에 자신의 영역 내에서 code, data, heap 외에 스택을 부여하여 해당 일처리를 할 수 있게 도와줍니다

## 3. TCP 상태에 대해

- closed
  - 닫혀 있는 상태이다. 요청을 보내거나 받을때 이 상태가 변하기 시작
- listen
  - 요청을 듣기위해 대기중인 상태
- syn received, syn sent
  - syn을 받은 상태와 보낸 상태이다. 요청을 보내고 받은 상태로 생각이 가능하다
- established
  - 클라이언트는 요청을 보낸 것에 대해 ack패킷을 받아 연결이 성공이 되었을때 서버측은 ack패킷을 보낸 것에 대해 성공했다는 요청을 받았을때 서로 연결이 되었다는 상태를 나타낸다
- fin-wait-1
  - 4way를 위해 fin 요청을 보낸 상태
- fin-wait-2
  - fin요청을 보낸 것에 대해 ack를 받았고 fin신호를 받기 위한 대기 상태
- close-wait
  - 서버측에서 연결을 끊기 위해 준비하고 있는 상태
- last-ack
  - 서버측에서 연결을 끊을 준비가 되었다고 fin 요청을 보내는 상태
- time-wait
  - 클라이언트 측에서 fin신호를 받았고 ack신호를 돌려 보내면서 연결을 끊기 위해 시간을 기다리는 상태
- closed
  - 클라이언트측은 ack신호를 보내고 시간이 조금 흐른 후 연결이 끊겼다고 상태를 전환, 서버측은 fin 신호에 대한 ack신호를 받고 연결이 끊겼다고 인지하고 연결끊음 상태로 바뀐 것

## 4. C++ set은 실제로 어떤 자료구조적 관점에서 어떤 자료구조일지

- set 컨테이너는 연관 컨테이너 중 단순한 컨테이너로 key라 불리는 원소의 집합으로 이루어진 컨테이너
- 노드 기반의 컨테이너이며 균형 이진 트리로 구현되어 있다.

## 5. sql injection 대응

1. 인풋값을 철저하게 검사한다
2. 에러 메시지를 감출 수 있도록 한다
3. 최소한의 권한으로 db운영
4. prepare statement
5. 신뢰할 수 있는 네트워크만 접근가능하게

## 6. LRU, LFU, FIFO

- LRU
  - 가장 오랫동안 참조되지 않은 캐시를 먼저 삭제
  - 단점: 계속해서 페이지에 대한 시간을 기록해야함. 큰 오버헤드 발생
- LFU
  - 참조 횟수가 가장 적은 것부터 삭제
  - 참조될 가능성을 무시한다.
- FIFO
  - 적재된 시간을 기준으로 교체할 페이지 선정
  - 중요한 페이지가 오래 있었다는 이유로 삭제 가능성이 있음

## 7. 하노이탑 의사코드

가정) 1번 위치에 있는 N개를 3번 위치로 옮겨야 한다

1. 2번 위치로 N-1개를 옮긴다
2. 1번 위치에 남은 제일 큰것을 3번으로 옮긴다
3. 2번 위치에 있는 N-1개를 이제 3번 위치로 옮긴다

## 8. 시프트 오버플로우 언더플로우

이거 찾아보는중. 생각은 미리 저장해두긴 하는건데 이걸 어떻게 해결해야하지?

## 9. 소수판별

[참고 사이트](https://teus.tistory.com/687)

1. 에라토스테네스의 체
2. 루트 N까지 증가시키며 나누기
3. 2번 비슷한데 반대로 i를 증가시키는데 i**2이 N보다 커지면 스탑

# 10. cpu 스케줄링

1. 선점형
   1. SRT 스케줄링
      - 짧은 시간이 걸리는 프로세스부터 실행을 시킵니다
      - 어떤 작업이 진행중이어도 새로 들어온 작업이 더 짧다면 그 프로세스를 실행시킵니다
      - 문제는 모든 프로세스에 대해 그 시간을 계산을 해야한다는 것 + 시간이 오래 걸리는 프로세스는 기아현상
   2. Round Robin
      - 준비 큐에서 큐방식으로 하나씩 실행을 시켜본다
      - 만약 지금 실행중인 프로세스가 설정해둔 시간내에 완료를 못하면 큐 맨뒤로 상태를 저장한다
      - 그리고 큐에 있는 다음프로세스를 실행
      - 만약 지금 실행중인 프로세스가 완료되면 완료시킨다
      - Context Switching의 오버헤드를 감수해야함
   3. Multi level Queue
      - 우선순위를 통해 우선순위가 높은 프로세스에 먼저 cpu를 할당 시켜줌
      - 우선순위 낮은 프로세스의 기아현상이 일어날 가능성이 높다
   4. 멀티 래밸 피드백 큐
      - 기본 개념은 멀티래밸과 같다
      - 실행 프로세스가 시간을 초과하면 우선순위 낮은 큐에 삽입이 된다
2. 비선점형
   1. FCFS
      - 먼저 오면 먼저 처리
      - 평균 기다림 시간에서 손해볼 가능성이 존재한다
   2. SJF
      - 시간이 짧은 프로세스부터 할당

## 11. 응답코드

- 200: 정상
- 304: 요청한 리소스가 마지막 요청 이후 변경된 적이 없음 때문에 기존 클라이언트의 로컬 캐시 리소스를 사용하도록 알려줌
- 401: 인증 정보 필요
- 404: 낫파운드
- 500: 서버 에러
- 503: 서버가 일시적으로 요청을 처리할 수 없음

## 12. fragmentation, 쓰레싱, virtual memory

1. fragmentation
   - External fragmentation: 연속적으로 저장할 시 남아있는 메모리 공간이 지금 필요한 공간보다 크지만 남아있는 메모리 공간이 단편화 되어 있어 할당을 할 수 없는 상태
   - Internal fragmentation: 용량 초과
2. 쓰레싱
   - 프로세스에서 감당할 수 없이 Paging in, out이 증가하여 프로세스의 CPU utilization이 감소하는 현상을 쓰레싱이라 한다.
   - locality를 고려하여 working set model을 사용하여 쓰레싱이 발생했는지 판단
3. 가상 메모리
   - 프로세스는 ready - run - wait 상태를 돌고 돌면서 메모리에 할당된다. 물리 메모리는 모든 것을 저장하기에는 턱없이 부족하다. wait상태는 굳이 주메모리에 올릴 필요가 없어보임 => 보조메모리에 저장시켜두고 필요한 순간에만 ram에 올린다 = 가상메모리

## 13. CSRF, CORS, XSS

- CORS (cross origin resource sharing)
  - AJAX는 동일한 도메인에서 제공되는 주소에서 시작되어야 한다
- CSRF (Cross site request forgery)
  - csrf는 악의적인 웹사이트, 전자 메일, 블로그, 인스턴트 메시지 또는 프로그램으로 인해 사용자의 웹 브라우저가 사용자가 인증 된 다른 신뢰할 수 있는 사이트에서 원치 않는 작업을 수행 할 때 발생하는 공격 유형이다.
- XSS (cross site scripting)
  - xss는 주입식 공격이다. 공격자가 악의적인 스크립트를 신뢰할 수 있는 웹사이트에 삽입하는 방법의 공격 세가지 유형이 존재한다
    1. Stored XSS: 보호되지 않고 검수되지 않은 사용자 입력으로 인한 취약점(데이터 베이스에 직접 저장되어 다른 사용자에게 표시됨)
    2. Reflected XSS: 웹 페이지에서 직접 사용되는 URL의 비보안에 의해 발생하는 취약점
    3. DOM based XSS: 웹페이지에서 직접 사용되는 URL의 비보안에 의해 발생한 취약점이라는 점에서 reflected xss와 비슷하지만 DOM based XSS 는 서버측으로 이동하지 않는다

