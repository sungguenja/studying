# 리액트 이것만은 알고가자

## React js

`npx create-react-app <app-name>` 로 간단하게 리액트 프로젝트가 시작된다.
Vue\(`npm run serve`\)와 달리 `npm start`로 바로 띄울 수 있다.

## 파일 구조
Package.json에서 라이브러리를 관리한다고 생각하자.
Public/index.html이라는 파일에서 그려진다고 생각해라

## 컴포넌트와 JSX
각 부분을 컴포넌트로 만들어서 조립한다고 생각해라\(머 프레임워크가 다 이러니 당연하다고 생각된다\)
리액트에서는 함수를 JSX를 리턴해서 렌더링한다고 생각해보자.
Style은 객체로 전달해야한다. \(그런데 우리는 html인라인에 스타일이 있는 것이 그렇게 좋지 않다는 것을 잘 알고 있다 그러니 왠만하면 클래스로 스타일을 조절할 수 있도록 하자. 클래스 이름에 대해서는 당연하게 주의해야함을 기억하자\)
그런데 우리 인간은 어쩔 수 없이 실수를 하기 마련이다. 그렇다면 어떤 방법이 있을까? 바로 모듈css가 있다! 보통 이름을 지어주는 방식은 `해당 모듈을 이용할 컴포넌트의 이름.module.css`로 지어주고 컴포넌트에서 `import 적당한 이름 from 모듈이름`으로 한 다음에 이제 해당 스타일을 적용할 태그에 `className={import한이름.원하는스타일속성}` 이런식으로 해주면 잘 적용된다! \(이거 뷰에도 비슷한거 있나?\)
`{}`를 이용하여 식을 전개하거나 컴포넌트 내에서 지정한 것들을 표현할 수가 있다. 
component라는 폴더에서 관리하는 것을 당연하게 추천한다. 그리고 컴포넌트는 언제나 `export default`를 이용하여 해당 컴포넌트의 결과 를 리턴해준 다는 것을 기억하자
그런 다음 필요한 view에서 필요한 컴포넌트를 import를 해주고 그냥 간단하게 뷰에서 컴포넌트를 넣듯이 넣으면 된다!
vue와 마찬가지로 리액트도 하나의 태그를 반환해야한다!

## 이벤트 처리
첫번째 방법은 컴포넌트에 함수를 만들어두고 on이벤트 속성을 이용해 지정해주는 방식이다\(해당 방식도 우리가 그닥 적절치 않은 방법이란 것은 알고 있다\)
두번째 방법은 on이벤트 속성 안에 아예 로직을 전개하는 방식이다\(더 안좋은데?\)

## State, useState
나는 개인적으로 이게 리액트의 꽃이지 않나 싶다. 옛날에 들었으면 왜 굳이 이렇게 어렵게 바꿔야하지? 했을텐데 클린 아키텍처 아주 조금익히고 나서 알게되니까 아주 납득이 되는 구조이다.
`const \[변수,set변수\] = useState\(값\);`을 이용해서 할당하는 방식을 이용한다. 그리고 state는 해당 컴포넌트에서 관리한다. 해당 컴포넌트가 중복으로 많이 이용된다 해도 해당 컴포넌트만 관계있다!

## Props
컴포넌트에 필요한 `key=value`로 속성을 지정해주고 컴포넌트에 파라미터로 props를 넣어주고 props를 인쇄해보면 key,value로 이뤄진 객체임을 확인할 수가 있다. 그렇다면 우리는 이 파라미터를 다르게 받을 수도 있다는 것을 안다! 직접 해보자. 만약 props값을 변경하고 싶다면 useState를 이용하여 새로 상태를 만들도록 하자. 직접 수정하는 것은 리액트가 거부한다.
상위 컴포넌트나 뷰에서 props를 수정해준다면 하위 컴포넌트에 내려진 props도 같이 수정이 된다!

## Map
JSX에도 map이 있다. 그래서 아래와 같이 이용이 가능하다
{dummy.days.map\(day => {<li key={day.id}>Day {day.day}</li>}\)}
이런식으로 리턴을 시키는 것으로 반복 렌더링이 가능하다

## 라우터
다른 라우터가 있는지 모르겠다. 하지만 일단 여기서 알려주는 방식은 `npm install react-router-dom`이다.
그리고 필요시 react-router-dom에서 BrowserRouter, Route, Switch를 임포트 해주면 된다.
위를 이용하는 방식은 BrowserRouter 태그가 전체를 감싸고 라우팅이 필요한 부분에 Swtich태그를 이용한 다음 Route태그를 이용하여 라우팅해서 안에 필요한 컴포넌트를 넣으면 된다. path속성으로 표시하는데 정확하게 하고 싶다면 exact속성을 추가 해주면 완벽하게 해당 라우터일때만 랜더링을 하게 한다
라우트 푸시는 Link라는 태그를 이용한다.
Path variable은 Route속성에서 path에 필요한 변수에 :를 붙여주면 된다\(뷰가 생각나는군\) 그리고 연결된 주소 컴포넌트에서 사용하고 싶다면 useParams를 이용하면 된다. 어렵지 않다

## useEffect
어떤 상태가 바뀌었을때 동작하는 함수를 만들 수 있다. 파라미터로 함수를 받는 녀석이다. 함수가 호출되는 타이밍은 페인팅 이전 단계인듯 하다 \(이건 라이프 사이클을 보고 좀 공부 따로 해야할 듯\). 하지만 매번 변경되면 일어난다는 것이 문제긴 하다. 그것을 해결하기 위해 두번째 매개변수에 변수가 들어있는 리스트를 넘기면 그 변수가 변할 때만 함수가 사용되게 된다. 의존성 뭐시기라고 함 검색해봐. 비동기를 위해 자주 사용하는 것인가? 이것도 좀 알아봐야할 듯. 빈배열을 넣으면 한번만 실행하게 하는 듯\(이런 이유로 그냥 시작할 때 비동기 로직에 대해 필요한 데이터를 불러내는 용도로 쓰는듯?\) `${}`이걸 쓰고 싶다면 안에 넣을 변수를 파라미터에 넣어주는 것이 좋다. 딱히 실행이 안되는 것은 아닌데 경고는 날라올 것이다.

## 검색해야할 것

App.test.js, reportWebVitals\(강의에서 퍼포먼스 관련 내용이라고 하고 그냥 지워버려서 알 필요가 있을 거 같다.\), Index.js, react life cycle이 있는가? 상태관리, module.css\(vue에도 비슷한게 있나 덤으로 더 검색해보자\), 리액트 이벤트 처리, 리액트 훅, useEffect, custom hook, useHistory


