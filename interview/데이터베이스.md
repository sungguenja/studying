# 데이터베이스

## NoSQL

SQL 관계형 데이터베이스가 데이터 저장에 있어서 오랫동안 표준으로 자리했다. 하지만 다른 유형의 데이터 베이스가 널리 퍼지면서 인기가 생기게 되었다. 그것이 NoSQL이다.

## 객체 데이터베이스

객체 데이터베이스는 데이터를 관계형 데이터베이스에서처럼 테이블에 저장하지않고, 객체지향 프로그래밍에서 같이 객체 모형으로 저장하는 데이터베이스다. 보통 계층적 구조를 지니며 SQL같은 전문 언어 대신 API를 통한 함수를 호출하여 데이터를 저장하거나 꺼낸다. 객체 데이터베이스의 가장 큰 장점은 객체 모형과 객체 데이터베이스 스키마 사이에서 일관성을 유지할 수 있다는 점이다. 사용 방법에 따라 객체 데이터베이스가 속도면에서도 유리할 수 있다. 계층구조 덕분에 노드를 따라가는 식으로 특정 데이터 원소를 빠르게 액세스할 수 있기 때문이다.

대부분의 객체 데이터베이스는 계층적이고, 각각의 인스턴스는 애플리케이션 데이터 모형 안에서 객체의 인스턴스를 나타낸다. 저장하고 불러오는 것은 빠르지만 유연성은 떨어질 가능성이 높다

## 혼성 키-값/열 데이터베이스

SQL 데이터베이스의 관계 모형에서 임의적으로 결합할 수 있게 하는 유연성의 성능 제한을 해결하기 위해 개발되었다. 대규모 읽기/쓰기가 필요한 상황에서는 그런 유연성이 필요하지 않음에도 불구하고 확장성 면에서 문제가 생긴다. 예를 들어, sns 상태 업데이튼는 읽기/쓰기는 매우 많이 일어나지만 둘 이상의 사용자 사이를 연결할 일은 거의 없다. 이러한 것을 해결하기 위해 [카산드라](https://ko.wikipedia.org/wiki/%EC%95%84%ED%8C%8C%EC%B9%98_%EC%B9%B4%EC%82%B0%EB%93%9C%EB%9D%BC) 같은 데이터 베이스가 개발되었다. 확장성으 보통 수평적이어서 부하가 늘어나도 서버를 추가하면 선형적인 확장이 가능하다.

이런 데이터베이스는 sql데이터베이스와 달리 **비정규화와 중복**이 따르기 마련이다. 이런 특성 때문에 **저장공간도 많이 필요하고 데이터 일관성과 무결성 유지가 어렵다.** 그럼에도 **읽기 성능 최적화**를 위해 감수할 만도 하다.

## 데이터베이스 트랜잭션

데이터베이스의 무결성(정확성, 일관성, 유효성의 유지)은 정말 중요하다. 문제가 생기면 서비스가 멎어버리거나 오류를 발생하기 때문이다. 무결성을 위해 가장 좋은 방법은 **데이터베이스 트랜잭션**이다.

트랜잭션은 한 단위를 이루는 일련의 연고나된 데이터베이스 조작을 의미한다. 한 트랜잭션에 속하는 작업 중 하나라도 실패하면 트랜잭션 전체가 실패한 것으로 간주 **롤백**을 실행한다. 반대로 모든 작업이 성공적으로 처리되면 모든 변경 내용을 한꺼번에 **반영(커밋)**시킨다. 트랜잭션은 아래와 같은 특징**(ACID)**을 가진다

- 원자성(Atomicity)

  트랜잭션에 포함되는 모드 작업이 성공적으로 처리되지 않음면 트랜잭션에 있는 어떤 작업도 처리되지 않아야 한다.

- 일관성(Consistency)

  트랜잭션은 트랜잭션이 시작되기 전과 트랜잭션이 종료된 후에 데이터베이스가 올바르고 일관된 상태가 되도록 처리되어햐 한다. 예를 들어, 참조 무결성이 깨지거나 하는 일이 일어나면 안 된다.

- 고립성(Isolation)

  한 트랜잭션에서 데이터베이스를 변경한 내용은 트랜잭션이 커밋될 때까지 다른 어떤 질의나 트랜잭션과도 고립되어야마 한다.

- 영속성(Durabillity)

  일단 커밋이 되고 나면 트랜잭션에 의해 변경된 내용은 영구적이어야 한다. 데이터베이스 시스템은 데이터베이스의 현재 상태가 유실되지 않도록 시스템 충돌 등의 문제로부터 복구할 수 있는 방법을 갖추고 있어야한다.

위 네가지를 모두 반영하려면 성능 면에서 큰 손해를 감수해야만 한다. 특히, 고립성은 유지가 매우 힘들기 때문에 어느정도 유연성 있게 완화시키는 편이다.

## 분산 데이터베이스

데이터 집합이 커질수록 대부분 분산형으로 가게 된다. 즉 데이터가 네트워크로 연결된 여러 위치에 저장된다. **중복성**과 **지연시간 감소** 및 **상황에 따른 비용 절감** 같은 장점이 있다. 따라서 실무에 쓰이는 데이터베이스는 여러 노드로 구성되며 서로 다른 데이터 센터에 나눠져 있는 경우도 많다. 그리고 다음과 같은 정리**(CAP)**가 있다.

- 일관성 (Consistency)

  모든 일기 작업에서는 가장 최근에 쓰여진 것을 반환한다.

  예를 들어 분산 은행 업무 애플리케이션이 있는데 최근에 어떤 노드에서 계좌에 입금을 했다면 다른 어떤 노드에서 읽기 작업을 하든 가장 최근의 계좌 잔고가 반영되어 잇어야 한다.

- 접근성 (Accessibillity)

  모든 요청에 대해 응답이 따륻나. 하지만 반드시 가장 최근에 쓰인 내용이 반영되는 것은 아니다.

  예를 들어, 어떤 분산 은행 업무 애플리케이션에서 언제 어느 노드에 대해 계좌 정보에 대한 질의를 하든 그 질의에 대하 응답을 받아볼 수 있다. 하지만 반드시 그 계좌의 최신 잔고 값을 받지는 못할 수도 있다.

- 구분성 (Partitionalbillity)

  시스템을 노드로 구분할 수 있으며 네트워크상의 노드 사이에서 데이터가 유실되더라도 시스템은 계속 제 기능을 한다.

  예를 들어, 분산 은행 업무 애플리케이션에서 일부 노드가 다운되더라도 시스템 전체는 여전히 작동한다.

모두 충족이 된다면 좋겠지만 일관성과 접근성은 당연히 동시에 만족시킬 수가 없다. 동시에 만족시키면 분산 데이터베이스가 아니기 때문이다.

## 데이터 베이스 문제

프로그래밍 관련 업무를 하다 보면 데이터베이스 작업도 많이 하게 된다. 이력서에 조금이라도 데이터베이스를 다룬 경험이 있다고 적어놨다면 면접관이 데이터베이스 분야에 대해 질문을 할 것이 뻔하다.

- ## 간단한 SQL

  > 다음과 같은 테이블이 있는 데이터베이스가 주어졌다고 하자.
  >
  > ```java
  > Olympics(
  > 	city CHAR(16),
  >     year INTEGER(4)
  > )
  > ```
  >
  > Montreal과 1976을 데이터베이스에 입력하기 위한 ssql문을 작성하라.

  정말 sql문을 써본 경험이 있는지이다. 너무 쉽지 않은가

  ```sql
  insert into Olympics values("Montreal",1976);
  ```

- ## 회사 및 직원 데이터베이스

  > 다음과 같은 테이블이 있는 데이터베이스가 주어졌다고 하자.
  >
  > ```java
  > Company (
  > 	companyName CHAR(30),
  >     id INTEGER(4) PRIMARY KEY
  > );
  >     
  > EmployeeHired (
  > 	id INTEGER(4) PRIMARY KEY,
  >     numHired INTEGER(4),
  >     fiscalQuarter INTEGER(4),
  >     FOREIGN KEY (id) REFERENCES Company
  > )
  > ```
  >
  > 화계 분기(fiscalQuarter)에는 1~4만 들어갈 수 있다고 가정해도 된다.
  >
  > | Company Name        | ID   |
  > | ------------------- | ---- |
  > | Hillary Plumbing    | 6    |
  > | John Lawn Company   | 9    |
  > | Dave Cookie Company | 19   |
  > | Jane Electricity    | 3    |
  >
  > | ID   | NUMHIRED | FISCALQUARTER |
  > | ---- | -------- | ------------- |
  > | 3    | 3        | 3             |
  > | 3    | 2        | 4             |
  > | 19   | 4        | 1             |
  > | 6    | 2        | 1             |
  >
  > 4분기에 직원을 고용한 모드 회사의 이름을 반환ㄴ한는 SQL문을 작성하라

  두 테이블을 결합해야만 한다. 다음과 같이 짤 수가 있다.

  ```sql
  SELECT companyName FROM Company, EmployeeHired
  WHERE Company.id = EmployeeHired.id AND fiscalQuarter = 4;
  ```

  위 경우는 4분기에 고용하지 않은 회사도 반환하게 된다. 그러면 다음과 같이 수정이 가능할 것 같다

  ```sql
  SELECT companyName FROM Company, EmployeeHired
  WHERE Company.id = EmployeeHired.id AND fiscalQuarter = 4 AND numHired > 0;
  ```

  > 이번에는 같은 스키마를 써서 1분기부터 4분기까지 한명도 고용하지 않은 회사 이름을 몸두 반환하는 sql문을 작성하라

  뭐 다양하게 하는 방식이 있겠지만 역으로 한명이라도 뽑은 집합에 포함되는지 검색하는 형태로 뽑아도 될 것 같다.

  ```sql
  SELECT companyName FROM Company WHERE id NOT IN
  (SELECT id from EmployeeHired WHERE numHired > 0);
  ```

  > 마지막으로 모든 회사의 이름과 1분기에서 4분기까지 그 회사에서 고용한 직원 수를 각각 구하라

  group by를 이용하면 쉽게 묶을 수가 있을 것 같다.

  ```sql
  SELECT companyName, SUM(numHired)
  FROM Company, EmployeeHired
  WHERE Company.id = EmployeeHired.id
  GROUP BY companyName;
  ```

  하지만 이 경우에는 employee hired에 없으면 이름이 안뜨는 경우가 있을 것이다! 어떻게 해결이 가능할까? outer join을 이용하자

  ```sql
  SELECT companyName, COALESCE(SUM(nimHired),0)
  FROM Company
  LEFT OUTER JOIN EmployeeHired ON EmployeeHired.id = Company.id
  GROUP BY companyName;
  ```

## 요약

요즘은 많은 애플리케이션에서 데이터베이스를 사용하며, 그중에서도 웹 기반 애플리케이션은 상당수가 데이터베이스와 밀접하게 연관되어 있다. sql에 대한 기초적인 이해부터 필요하고 nosql개념이나 분산 데이터베이스, 트랜잭션, 삼진 논법에 관한 문제가 나올 수도 있다.