# CSS 방법론

[영상 링크](https://www.youtube.com/watch?v=B70h37mpD74)

> 1. CSS란?
> 2. CSS 등장 이전/이후의 스타일링
> 3. CSS의 문제점
> 4. OOCSS
> 5. SMACSS
> 6. BEM
> 7. 새로운 CSS 방법론

## 1. CSS란?

- HTML 또는 XML로 쓰여진 문서의 스타일을 나타내기 위해 사용되는 언어
- 문서의 구조와 스타일을 분리하게 되었다

## 2. CSS 등장 이전/이후의 스타일링

1. 이전

   직접 style속성으로 스타일을 일일이 지정

   문제점

   - 같은 스타일 요소를 여러 페이지마다 사용하면, 하나를 수정할 때마다 그만큼 반복하여 수정을 해야 한다
   - HTML은 본래 문서 구조를 의미하므로 HTML에 직접 스타일을 지정하는 것은 바람직하지 않다

## 3. 문제점

- CSS에서는 모든 것이 전역 범위라 모든 스타일링이 서로 간섭할 가능성이 있다
- CSS파일이 분리되어 있다 하더라도 이 파일들을 읽어 들인 HTML 에서는 모든 스타일링이 동일한 범위 안에 존재하게 된다
- 웹사이트가 점점 복잡해지면서 유지보수가 용이한 CSS를 작성하는 것이 어려워졌고, 이를 해결하기 위한 CSS 방법론이 여러 가지 대두되었다.

## 4. OOCSS

- Object Oriented CSS: 객체 지향 CSS
- 주요 발상
  - 레고처럼 자유로운 조합이 가능한 모듈의 집합을 만든다
  - 그 모듈을 조합해 페이지를 만든다
  - 그리하여 신규 페이지를 만드는 경우에도 기본적으로 추가적인 CSS를 만들 필요가 없다
- 원칙
  - 스트럭처와 스킨 분리
  - 컨테이너와 콘텐츠 분리
- 정리
  - OOCSS의 역사는 매우 길며 명확하게 규칙이라고 불리는 것도 많지 않다
  - 다른 CSS 방법론들은 기본적으로 크건 작건 OOCSS를 참조하면서 개선한 것
  - 오늘날 OOCSS 한 가지만으로 실질적인 CSS 설계를 수행하는 것은 그다지 현실적이지 않음

## 5, SMACSS

- Scalable and modular architecture for css
- css 코드를 그 역할에 따라 분류한 것이 특징
  - 베이스
    - 프로젝트의 표준 스타일을 정의
    - 리셋 css도 베이스 규칙에 포함
  - 레이아웃
    - 헤더, 메인 영역, 사이드 바 등 웹사이트의 레이아웃을 구성하는 큰 모듈에 관한 규칙
    - 대부분 특정 페이지에서 한 차례만 사용하므로 ID 셀렉터를 활용한 스타일링을 허용
    - 반복적으로 사용하는 모듈의 경우에는 클래스 셀렉터를 이용
    - 특정 페이지에서만 레이아웃을 변경하고 싶다면
      - 손자 셀렉터를 이용해 레이아웃 모듈의 스타일을 덮어씀
  - 모듈
    - 타이틀, 버튼, 카드, 내비게이션 등
    - 모든 모듈은 레이아웃 규칙 안에 배치되는 것을 가정
    - 다른 페이지로 이동하거나 다른 레이아웃 안에 삽입하더라도 형태가 부서지거나 달리지지 않고 사용할 수 있어야 함
      - 특정 컨텍스트에 지나치게 의존하지 않아야 함
    - 루트 요소에는 반드시 클래스 셀렉터를 사용
  - 스테이트
    - 기존 스타일을 덮어쓰거나 확장하기 위해 사용
    - 기존 스타일을 모두 덮어써서 스테이트 스타일을 반영하는 것을 기대하기 때문이에 `!important`사용도 권장
    - 스테이트는 레이아웃이나 모듈에 할당할 수 있따
    - 스테이트 규칙에 따른 클래스 이름은 모드 `is-` 접두사를 붙인다
  - 테마
    - 사이트 내 레이아웃이나 색상, 텍스트 처리 등을 일정한 규칙에 따라 덮어쓰는 것
    - 기존의 다양한 스타일링이 덮어쓰기의 대상이 된다
    - 다크모드, 테마 컬러 변경 등
    - `theme` 접두사를 붙일 것을 권장
- 정리
  - 프로젝트에서 고려해야 하는 대부분의 CSS 규칙을 포함
  - 엄격하지 않아 유연하나, 너무 유연하기도 함

## 6. BEM

- Block, Element, Modifier

- UI를 독립된 블록으로 분리함으로써 복잡한 페이지에서도 간단하고 신속하게 개발을 수행하는 것이 목적

- 기본적으로는 모듈 기반의 방법이지만, 그 내용이 다른 설계 기법에 비해 엄격하고 강력하여 세계적으로 이름이 알려졌으며 실제로 널리 사용되고 있다

- Block

  - 재사용할 수 있는 기능적으로 독립적인 페이지 구성요소
  - BEM을 사용할 때는 ID 셀렉터 또는 요소 셀렉터를 사용해서는 안됨
  - Block이름은 상태가 아닌 용도를 나타내야 한다.
    - :x: - red-btn
    - :+1: - error
  - 환경에 영향을 미치지 않아야 한다. 즉, Block 자체에 대한 외부 지오메트리 또는 Block의 위치를 설정하지 않아야 한다
  - 서로 중첩될 수 있다.

- Element

  - Block의 복합 부품으로 Block과 별도로 사용할 수 없다
  - 상태가 아닌 용도를 나타내야 한다
  - 명명법: `block-name__element-name`
  - element는 항상 block의 부분이어야 하며, block으로부터 분리하여 사용해서는 안된다
  - 모든 block이 element를 가지는 것은 아니다
  - element는 서로 중첩될 수 있다.
  - block vs element
    - 구현된 다른 페이지 컴포넌트에 의존하지 않고 코드가 재사용된다 => block
    - 부모 엔티티 없이 구분해서 사용할 수 없다 => element
    - 더 작은 부분으로 나뉘어져야 하는 elements => block / mix
      - BEM에서는 elements의  elements는 만들 수 없다

- Modifier

  - Block 또는 Element의 모양, 상태 또는 동작을 저으이

  - Modifier이름은 모양, 상태, 동작을 나타낸다

    - `size_s`, `them_islands`, `disabled`, `focused`, `directions_left-top`

  - modifier는 홀로 사용되지 않는다

  - 유형

    1. Boolean

       1. modifier 유무만 중요하고 그 값이 무관할 때 사용
       2. Boolean modifier가 있으면 해당 값이 참으로 간주됨
       3. 명명법: `block-name_modifier-name`, `block-name__element-name_modifier-name`

    2. key-value

       1. modifier 값이 중요한 경우에 사용

       2. 명명법

          `block-name--modifier-name_modifier-value`

          `block-name__element-name_modifier-name_modifier-value`

- Mix

  - block과 element가 하나의 html 요소에 존재하는 것을 의미
  - 코드 중복을 피하면서 여러 BEM 엔티티의 동작과 스타일을 결합
  - 기존 BEM 엔티티를 기반으로 의미상 새로운 인터페이스 컴포넌트를 작성
  - 가급적 상세도를 높이지 않고 block의 독립성을 유지할 수 있음

## 7. 새로운 CSS 방법론

- 기존의 문제점
  - CSS가 HTML 구조와 강하게 결합
  - HTML과 CSS가 서로 의존